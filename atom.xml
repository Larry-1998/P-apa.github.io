<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宗沅のBLOG</title>
  
  <subtitle>一步一步往上爬的瓜牛</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://daofenglee.cn/"/>
  <updated>2020-09-24T12:37:38.158Z</updated>
  <id>http://daofenglee.cn/</id>
  
  <author>
    <name>宗沅</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java异常处理机制</title>
    <link href="http://daofenglee.cn/2020/09/24/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://daofenglee.cn/2020/09/24/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</id>
    <published>2020-09-24T11:45:40.099Z</published>
    <updated>2020-09-24T12:37:38.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java异常处理机制"><a href="#Java异常处理机制" class="headerlink" title="Java异常处理机制"></a>Java异常处理机制</h1><h3 id="一、异常的概述"><a href="#一、异常的概述" class="headerlink" title="一、异常的概述"></a>一、异常的概述</h3><p>Java程序在执行过程中所发生的异常事件可分为两类：</p><ol><li><p><code>Error</code>：Java虚拟机无法解决的严重问题。如栈溢出，堆溢出(OutOfMemory)。需要改代码。</p></li><li><p><code>Exception</code>: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。比如：空指针访问、试图读取不存在的文件、网络连接中断、数组角标越界等。</p></li></ol><p>而我们说的异常通常指的是可以使用针对性的代码进行处理的异常，即<code>Exception</code>类异常。后面的内容也是对<code>Exception</code>类异常的讲解。</p><h3 id="二、Exception异常分类"><a href="#二、Exception异常分类" class="headerlink" title="二、Exception异常分类"></a>二、Exception异常分类</h3><p><strong>运行时异常</strong>：指编译器不强制处理的异常。一般是指编程的时逻辑错误。对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。</p><p><strong>编译时异常</strong>：编译器要求必须处理的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常。</p><h3 id="三、异常的体系结构及常见异常"><a href="#三、异常的体系结构及常见异常" class="headerlink" title="三、异常的体系结构及常见异常"></a>三、异常的体系结构及常见异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Throwable</span><br><span class="line">    |-----java.lang.Error:一般不编写针对性的代码进行处理。</span><br><span class="line">    |-----java.lang.Exception:可以进行异常的处理。</span><br><span class="line">        |-----编译时异常（checked）</span><br><span class="line">            |-----IOException</span><br><span class="line">                |-----FileNotFoundException</span><br><span class="line">                |-----EOFException</span><br><span class="line">            |-----ClassNotFoundException</span><br><span class="line">        |-----运行时异常（unchecked）</span><br><span class="line">            |-----NullPointerException</span><br><span class="line">            |-----ClassCastException（类型转换异常）</span><br><span class="line">            |-----ArithmeticException</span><br><span class="line">            |-----NumberFormatException</span><br><span class="line">            |-----InputMismatchException</span><br></pre></td></tr></table></figure><h3 id="四、异常处理机制"><a href="#四、异常处理机制" class="headerlink" title="四、异常处理机制"></a>四、异常处理机制</h3><p><strong>(一)、异常处理机制：“抓抛”模型</strong></p><p>过程一：“抛”<br>程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出。一旦抛出对象以后，此后的代码(try块内的)就不再执行。其中异常对象的生成有两种方式：(1)系统自动生成，(2)手动生成异常对象并抛出(<code>throw</code>，注意这里不是<code>throws</code>)</p><p>过程二：”抓”<br>可以理解为异常的处理方式：(2)try-catch-finally，(2)throws</p><p><strong>(二)、异常的第一种处理方式：try-catch-finally</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     <span class="comment">//可能出现异常的代码 </span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line">     <span class="comment">//处理异常的方式1</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line">     <span class="comment">//处理异常的方式2</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line">     <span class="comment">//处理异常的方式2</span></span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">     <span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li>finally是可选的；</li><li>使用try将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型去catch中进行匹配；</li><li>一旦try中的异常对象去配到某一个catch时，就进入catch中进行异常处理。一旦处理完成就跳出当前的try-catch结构（没有写finally的情况），继续执行其后的代码；</li><li>catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓；如果满足子父类关系，则要求子类一定声明在父类的上面，否则报错；</li><li>常用的异常处理方式：(1). <code>String getMessage()</code>,(2)<code>printStackTrace()</code></li><li>在try结构中声明的变量，出了try结构后就不能再被调用；</li><li>使用try-catch-finally处理编译时异常，使得程序在编译时不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时的异常延迟到运行时出现；</li><li>在开发中，由于运行时异常比较常见，所以通常我们就不针对运行时异常编写try-catch-finally。针对编译时异常，一定要考虑异常的处理。</li></ol><p>(三)、异常处理的第二种方式：throws+异常类型</p><ol><li><p>“throws+异常类型”写在方法声明处。指出该方法在执行时可能会抛出的异常类型。一旦当方法体执行时出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws语句后的异常类型时，就会被抛出。<strong>异常代码后续的代码，就不再执行！</strong></p></li><li><p>try-catch-finally的方式真正地将异常给处理掉了；而throws的方式只是将异常抛给了方法的调用者，并没有真正将异常处理掉。</p></li><li><p>开发中如何选择使用try-catch-finally 还是使用throws？</p></li></ol><ul><li>如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。<ul><li>执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。</li></ul></li></ul><h3 id="五、异常方法重写"><a href="#五、异常方法重写" class="headerlink" title="五、异常方法重写"></a>五、异常方法重写</h3><p>方法重写的规则之一：子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">OverrideTest test = <span class="keyword">new</span> OverrideTest();</span><br><span class="line">test.display(<span class="keyword">new</span> SubClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(SuperClass s)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">s.method();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span><span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、手动抛出异常：throw"><a href="#六、手动抛出异常：throw" class="headerlink" title="六、手动抛出异常：throw"></a>六、手动抛出异常：throw</h3><p>手动抛出异常是相对于系统自动抛出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">s.regist(-<span class="number">1001</span>);</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regist</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//手动抛出异常对象</span></span><br><span class="line">            <span class="comment">//  throw new RuntimeException("您输入的数据非法！");</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"您输入的数据非法！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Student [id="</span> + id + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、自定义异常类"><a href="#七、自定义异常类" class="headerlink" title="七、自定义异常类"></a>七、自定义异常类</h3><p>步骤：</p><ol><li>继承于现有的异常结构：<code>RuntimeException</code> 、<code>Exception</code></li><li>提供全局常量：serialVersionUID</li><li>提供重载的构造器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7034897193246939L</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h3><p>这里学的异常处理并不是解决异常的根本方法，而是将可能出现的异常以一种”友好”的方式展现出来。比如用户点击了一个按钮，此时代码出现了异常，如果不针对这个异常进行处理的话可能展示出来的就是一段乱码或程序直接闪退；而进行异常处理就可用对话框的形式向用户发出错误提示信息，也可以将这个错误信息发送到后台，供开发人员进行修改。<br>而对于异常根本的解决方法就是修改代码，解决这个异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java异常处理机制&quot;&gt;&lt;a href=&quot;#Java异常处理机制&quot; class=&quot;headerlink&quot; title=&quot;Java异常处理机制&quot;&gt;&lt;/a&gt;Java异常处理机制&lt;/h1&gt;&lt;h3 id=&quot;一、异常的概述&quot;&gt;&lt;a href=&quot;#一、异常的概述&quot; class
      
    
    </summary>
    
    
      <category term="编程语言" scheme="http://daofenglee.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Java" scheme="http://daofenglee.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>DFS算法的学习</title>
    <link href="http://daofenglee.cn/2020/09/17/DFS%E7%AE%97%E6%B3%95/"/>
    <id>http://daofenglee.cn/2020/09/17/DFS%E7%AE%97%E6%B3%95/</id>
    <published>2020-09-16T16:37:59.668Z</published>
    <updated>2020-09-24T11:44:09.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DFS算法的学习"><a href="#DFS算法的学习" class="headerlink" title="DFS算法的学习"></a>DFS算法的学习</h1><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a><strong>简述</strong></h3><p>首先，DFS (Depth First Search) 是一种在程序设计竞赛中常用的搜索算法。那么，什么是搜索？搜索可以是在众多数据中找到符合要求的一组数据；也可以是寻找一条从某一起点到目标终点的最佳路径。在这过程中可能会不断作出尝试性的选择来达到访问全局，最终得出结果。</p><a id="more"></a><h3 id="DFS算法思想"><a href="#DFS算法思想" class="headerlink" title="DFS算法思想"></a><strong>DFS算法思想</strong></h3><p>这有类问题在求解时需要一定的步骤。通常求解这些问题采取的策略是:从起始位置(或起始状态)出发，试探性的选择一个可行的步骤到达下一个状态， 而后又从这个状态出发选择一个可 行的步骤达到下一个状态 ……每到达 一个状态如果发现没有可行的步骤则回退到上一步，再试探其他可行的步骤;如果回退到上一步依然没有其他可行的步骤，则继续回退到再上一步;如此反复直到目标位置(或目标状态)，或者所有状态都访问完后还没有找到目标状态，则说明无解。</p><p>在图论中，深度优先遍历主要思路是从图中⼀个未访问的顶点 V 开始，沿着⼀条路⼀直⾛到底，然后从这条路尽头的节点回退到上⼀个节点，再从另⼀条路开始⾛到底……不断递归重复此过程，直到所有的顶点都遍历完成，它的特点是不撞南墙不回头，先⾛完⼀条路，再换⼀条路继续⾛。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a><strong>关键字</strong></h3><p>尝试性选择；回退；递归；当前状态；下一状态</p><h3 id="例题讲解"><a href="#例题讲解" class="headerlink" title="例题讲解"></a><strong>例题讲解</strong></h3><p>接下来通过三道题来理解DFS算法，三道题分别对应于三中不同的场景（矩阵、一位数组和二叉树）。</p><p><strong><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827365609" target="_blank" rel="noopener">1.骨头的诱惑</a></strong></p><p>题目来源：ZOJ2110</p><p>题目描述：<br>    一只小狗在一个古老的迷宫里找到一根骨头，当它叼起骨头时，迷宫开始颤抖，它感觉到地面开始下沉。它才明白骨头是一个陷阱，它拼命地试着逃出迷宫。<br>    迷宫是一个N×M 大小的长方形，迷宫有一个门。刚开始门是关着的，并且这个门会在第T 秒钟开启，门只会开启很短的时间（少于一秒），因此小狗必须恰好在第T 秒达到门的位置。每秒钟，它可以向上、下、左或右移动一步到相邻的方格中。但一旦它移动到相邻的方格，这个方格开始下沉，而且会在下一秒消失。所以，它不能在一个方格中停留超过一秒，也不能回到经过的方格。小狗能成功逃离吗？请你帮助他。<br>输入描述：<br>    输入文件包括多个测试数据。每个测试数据的第一行为三个整数：N,M,T，(1&lt;N, M&lt;7；0&lt;T&lt;50)，分别代表迷宫的长和宽，以及迷宫的门会在第T 秒时刻开启。接下来N 行信息给出了迷宫的格局，每行有M 个字符，这些字符可能为如下值之一：<br>    X: 墙壁，小狗不能进入 S: 小狗所处的位置<br>    D: 迷宫的门 . : 空的方格<br>    输入数据以三个0 表示输入数据结束。<br>输出描述：<br>    对每个测试数据，如果小狗能成功逃离，则输出”YES”，否则输出”NO”。</p><p>样例输入：<br>    3 4 5<br>    S . . .<br>    . X . X<br>    . . . D<br>    4 4 8<br>    . X . X<br>    . . S .<br>    . . . .<br>    D X . X<br>    4 4 5<br>    S . X .<br>    . . X .<br>    . . X D<br>    . . . .<br>    0 0 0</p><p>样例输出：</p><p>YES<br>YES<br>NO</p><p><strong>题目解析</strong><br>                略<br><strong>核心代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m,n,T,X,Y;<span class="comment">//m,n是矩阵的大小;T是第t秒到达;X,Y是终点坐标</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> matrix[m][n];<span class="comment">//迷宫矩阵</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> falg=<span class="keyword">false</span>;<span class="comment">//flag为true则成功逃离，false则没有</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[][] V=&#123;-<span class="number">1</span>,<span class="number">0</span>;<span class="number">0</span>,-<span class="number">1</span>;<span class="number">1</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">1</span>&#125;;<span class="comment">//用来表示上左下右四个方向</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="comment">//下面两个if语句是递归的结束条件，即遇到边界、找到答案</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=m||y&lt;<span class="number">0</span>||y&gt;=n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==X&amp;&amp;y==Y&amp;&amp;t==T)&#123;</span><br><span class="line">        flag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下是按上、左、下、右的顺序进行访问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[x+V[i][<span class="number">0</span>]][y+V[i][<span class="number">1</span>]]==<span class="string">'X'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        matrix[x][y]=<span class="string">'X'</span>;<span class="comment">//将空白处变为墙壁</span></span><br><span class="line">        DFS(x+V[i][<span class="number">0</span>],y+V[i][<span class="number">1</span>],t+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        matrix[x][y]=<span class="string">'.'</span>;<span class="comment">//回退</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a href="http://poj.org/problem?id=1011" target="_blank" rel="noopener">2.小木棍</a></strong></p><p>Description</p><p>乔治拿来一组等长的木棒，将它们随机地砍断，使得每一节木棍的长度都不超过50个长度单位。然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。请你设计一个程序，帮助乔治计算木棒的可能最小长度。每一节木棍的长度都用大于零的整数表示。</p><p>Input</p><p>输入包含多组数据，每组数据包括两行。第一行是一个不超过64的整数，表示砍断之后共有多少节木棍。第二行是截断以后，所得到的各节木棍的长度。在最后一组数据之后，是一个零。</p><p>Output</p><p>为每组数据，分别输出原始木棒的可能最小长度，每组数据占一行。</p><p>Sample Input</p><p>9<br>        5 2 1 5 2 1 5 2 1<br>        4<br>        1 2 3 4<br>        0</p><p>Sample Output</p><p>6<br>        5</p><p>题目要求木棒的最小长度，根据题目可知，木棒的最小长度应该不小于小木棍中最长的那一根的长度。以样例中第二组数据为例，先将小木棍的按有长到短进行排序，即4 3 2 1，假设木棒的长度为4，则组合为4;3,1;2,2!=4，不符合，此时设木棒的长度5，则可以得到组合4,1;3,2，符合题目要求，即最短长度为5。</p><p>样例的第一组数据则要麻烦些，排序后为5 5 5 2 2 21 1 1，</p><p><strong>关键代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pieceNum;    <span class="comment">//切割得到的小段总数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> stickLen;    <span class="comment">//小木棍的长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> stickNum;    <span class="comment">//小木棍的数目</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pieceLen[N];    <span class="comment">//小段的长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> isPieceUsed[N];    <span class="comment">//搜索过程中小段是否被使用</span></span><br><span class="line"><span class="comment">//正在拼接第filledStickNum根小木棍，已经得到的这根小木棍的长度filledLen</span></span><br><span class="line"><span class="comment">//选取小段时的起始编号（不用取编号在startNo之前的小段）</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">search</span><span class="params">( <span class="keyword">int</span> filledStickNum, <span class="keyword">int</span> filledLen, <span class="keyword">int</span> startNo )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( filledStickNum==stickNum )  <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">//存在满足要求的拼接方法</span></span><br><span class="line">    <span class="keyword">int</span> i, p;</span><br><span class="line">    <span class="keyword">for</span>( i=startNo; i&lt;pieceNum; i++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( isPieceUsed[i]==<span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="comment">//如果加入选取的小段之后，这根木棍还没有拼接完成</span></span><br><span class="line">            <span class="keyword">if</span>( (p=filledLen+pieceLen[i])&lt;stickLen ) &#123;</span><br><span class="line">                isPieceUsed[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>( search(filledStickNum,p,i+<span class="number">1</span>) )  <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">//剪枝1</span></span><br><span class="line">                isPieceUsed[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>( startNo==<span class="number">0</span> )  <span class="keyword">break</span>;    <span class="comment">//剪枝2</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( p==stickLen ) &#123;</span><br><span class="line">                isPieceUsed[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>( search(filledStickNum+<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>) )  <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">//剪枝1</span></span><br><span class="line">                isPieceUsed[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;    <span class="comment">//剪枝3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener"><strong>3.二叉树的最大深度</strong></a></p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><p><strong>关键代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> date;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> D,Node L,Node R)</span></span>&#123;</span><br><span class="line">        date=D;</span><br><span class="line">        left=L;</span><br><span class="line">        right=R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS3</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> L=DFS3(root.left)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> R=DFS3(root.right)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(L,R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener"> <strong>4.二叉树的最小深度</strong></a></p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回它的最小深度  2.</p><p><strong>关键代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS4</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+DFS4(root.right);</span><br><span class="line">    <span class="keyword">if</span> (root.right==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+DFS4(root.left);</span><br><span class="line">    <span class="keyword">int</span> L=<span class="number">1</span>+DFS4(root.left);</span><br><span class="line">    <span class="keyword">int</span> R=<span class="number">1</span>+DFS4(root.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+Math.min(L,R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;DFS算法的学习&quot;&gt;&lt;a href=&quot;#DFS算法的学习&quot; class=&quot;headerlink&quot; title=&quot;DFS算法的学习&quot;&gt;&lt;/a&gt;DFS算法的学习&lt;/h1&gt;&lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;首先，DFS (Depth First Search) 是一种在程序设计竞赛中常用的搜索算法。那么，什么是搜索？搜索可以是在众多数据中找到符合要求的一组数据；也可以是寻找一条从某一起点到目标终点的最佳路径。在这过程中可能会不断作出尝试性的选择来达到访问全局，最终得出结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://daofenglee.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://daofenglee.cn/tags/Java/"/>
    
      <category term="DFS" scheme="http://daofenglee.cn/tags/DFS/"/>
    
      <category term="算法" scheme="http://daofenglee.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://daofenglee.cn/2020/07/23/hello-world/"/>
    <id>http://daofenglee.cn/2020/07/23/hello-world/</id>
    <published>2020-07-23T09:51:57.809Z</published>
    <updated>2020-08-01T14:40:05.701Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="实验" scheme="http://daofenglee.cn/categories/%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="hexo" scheme="http://daofenglee.cn/tags/hexo/"/>
    
  </entry>
  
</feed>
