<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宗沅のBLOG</title>
  
  <subtitle>一步一步往上爬的瓜牛</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://daofenglee.cn/"/>
  <updated>2020-10-22T01:25:39.267Z</updated>
  <id>http://daofenglee.cn/</id>
  
  <author>
    <name>宗沅</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法设计与分析----分治法</title>
    <link href="http://daofenglee.cn/2020/10/22/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90--%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    <id>http://daofenglee.cn/2020/10/22/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90--%E5%88%86%E6%B2%BB%E6%B3%95/</id>
    <published>2020-10-22T01:23:38.582Z</published>
    <updated>2020-10-22T01:25:39.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><h3 id="一、算法基本思想"><a href="#一、算法基本思想" class="headerlink" title="一、算法基本思想"></a>一、算法基本思想</h3><p>对于一个规模较大的问题，可以将大问题分解为多个规模较小的子问题，这些子问题相互独立且与原问题形式相同，递归地求解这些子问题，然后将各子问题的解合并得到原问题的解。</p><a id="more"></a><p><strong>特征：</strong></p><ol><li>问题的规模缩小到一定的程度就可以容易地解决；</li><li>原问题可以分解为多个规模较小的相似问题；</li><li>原问题的解可以通过子问题的解合并得到；</li><li>子问题间相互独立，即不包含公共子问题。</li></ol><h3 id="二、求解排序问题"><a href="#二、求解排序问题" class="headerlink" title="二、求解排序问题"></a>二、求解排序问题</h3><h4 id="一-、快速排序-QuickSort"><a href="#一-、快速排序-QuickSort" class="headerlink" title="(一)、快速排序(QuickSort)"></a>(一)、快速排序(QuickSort)</h4><h5 id="1、算法分析"><a href="#1、算法分析" class="headerlink" title="1、算法分析"></a>1、算法分析</h5><p>对于快速排序，采取的步骤是：</p><ol><li>从待排序的数组中任意的选择一个元素（一般选择数组的第一个元素）为基准，然后将它放到最终的位置上，假设下标为i，即大于它的数在它右侧，小于它的数在它左侧；</li><li>将待排序数组以基准元素为中点，划分为左、右两个子序列（不包括基准元素）；</li><li>对两个子序列分别重复步骤1、2，直到序列的长度为1（即有序）。</li></ol><h5 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">QuickSort算法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iosttream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到数组array[from.....to]中基准元素的最终位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=from,j=to;</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="built_in">array</span>[from];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i!=j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;i $$ <span class="built_in">array</span>[j]&gt;=tmp)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="built_in">array</span>[i]=<span class="built_in">array</span>[j];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j $$ <span class="built_in">array</span>[i]&lt;=tmp)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="built_in">array</span>[j]=<span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[i]=tmp;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行划分排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=Partition(<span class="built_in">array</span>,from,to);</span><br><span class="line">    QuickSort(<span class="built_in">array</span>,from,i<span class="number">-1</span>);</span><br><span class="line">    QuickSort(<span class="built_in">array</span>,i+<span class="number">1</span>,to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、求解查找问题"><a href="#三、求解查找问题" class="headerlink" title="三、求解查找问题"></a>三、求解查找问题</h3><h3 id="四、求解组合问题"><a href="#四、求解组合问题" class="headerlink" title="四、求解组合问题"></a>四、求解组合问题</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分治法&quot;&gt;&lt;a href=&quot;#分治法&quot; class=&quot;headerlink&quot; title=&quot;分治法&quot;&gt;&lt;/a&gt;分治法&lt;/h1&gt;&lt;h3 id=&quot;一、算法基本思想&quot;&gt;&lt;a href=&quot;#一、算法基本思想&quot; class=&quot;headerlink&quot; title=&quot;一、算法基本思想&quot;&gt;&lt;/a&gt;一、算法基本思想&lt;/h3&gt;&lt;p&gt;对于一个规模较大的问题，可以将大问题分解为多个规模较小的子问题，这些子问题相互独立且与原问题形式相同，递归地求解这些子问题，然后将各子问题的解合并得到原问题的解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://daofenglee.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分治法" scheme="http://daofenglee.cn/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="http://daofenglee.cn/2020/10/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://daofenglee.cn/2020/10/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-10-22T01:21:56.708Z</published>
    <updated>2020-10-22T01:23:06.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><ol><li>程序(<code>program</code>):是为完成某一任务、用某种编程语言编写的指令集合。是一段<strong>静态</strong>代码。</li><li>进程(<code>process</code>):是程序的一次执行过程，或是一个正在运行的程序。是一个<strong>动态</strong>过程。</li><li>线程(<code>thread</code>):是一个程序内部的<strong>一条执行路径</strong>。</li><li>并行:多个CPU同时执行多个任务。</li><li>并发:一个CPU同时执行多个任务(比如，采用时间片的方式)。<a id="more"></a><h3 id="二、线程的创建和使用"><a href="#二、线程的创建和使用" class="headerlink" title="二、线程的创建和使用"></a>二、线程的创建和使用</h3><h5 id="一-、多线程的创建方式一：继承于Thread类"><a href="#一-、多线程的创建方式一：继承于Thread类" class="headerlink" title="(一)、多线程的创建方式一：继承于Thread类"></a>(一)、多线程的创建方式一：继承于Thread类</h5></li></ol><p>步骤：</p><ol><li>创建一个继承于Thread类的子类；</li><li>重写Thread类的子类的run()；</li><li>创建Thread类的子类的对象；</li><li>通过此对象调用start()。</li></ol><p><strong>注意：</strong></p><ol><li>不能直接通过调用run()启动线程；</li><li>当前线程正在执行的时候不能再去调用它的start()。</li></ol><p>创建线程实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gzy.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                System.out.println(getName()+<span class="string">": "</span>+i);<span class="comment">//输出偶数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread1 a=<span class="keyword">new</span> Thread1(<span class="string">"线程1"</span>);</span><br><span class="line">        Thread1 b=<span class="keyword">new</span> Thread1(<span class="string">"线程2"</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上述方式实现的线程存在安全问题！下面先给一个例子，原因后续章节会说明。</p><p>执行下面的代码输出结果有两个’100’，线程安全的情况不会有这种情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gzy.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeProblem</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num=<span class="number">100</span>;<span class="comment">//声明一个静态变量</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">" :"</span>+num--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ThreadSafeProblem a=<span class="keyword">new</span> ThreadSafeProblem();</span><br><span class="line">        ThreadSafeProblem b=<span class="keyword">new</span> ThreadSafeProblem();</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/P-apa/imageRepo@2.0/blog_img/Java%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8.png" alt="线程安全"></p><h5 id="二-、Thread类中常用的方法"><a href="#二-、Thread类中常用的方法" class="headerlink" title="(二)、Thread类中常用的方法"></a>(二)、Thread类中常用的方法</h5><ol><li>start()：启动当前线程；调用当前线程的run()；</li><li>run()：将创建的线程要执行的操作声明在此方法中；</li><li>currentThead() ：静态方法，返回当前代码的线程；</li><li>getName()：获取当前线程的名字；</li><li>setName：设置当前线程的名字；</li><li>yield() ：释放当前线程的CPU执行权；</li><li>join()：在线程a中调用线程b的join()，此时线程a进入阻塞状态，直到线程b完全执行完成以后，线程a才结束阻塞状态；</li><li><del>stop()</del>：强制结束当前线程；</li><li>sleep(long millitime) ：静态方法，让当前进程休眠指定的millitime毫秒。在指定的millitime毫秒内，当前进程处于阻状态；</li><li>isAlive()：判断当前进程是否结束。</li></ol><h5 id="三-、线程的调度"><a href="#三-、线程的调度" class="headerlink" title="(三)、线程的调度"></a>(三)、线程的调度</h5><p>Java的调度方法:时间片(队列)、抢占式(高优先级的线程抢占CPU)</p><p>Java中线程的三个优先级：</p><table><thead><tr><th align="left">Modifier and Type</th><th align="left">Field and Description</th><th align="center">VALUE</th></tr></thead><tbody><tr><td align="left"><code>static int</code></td><td align="left"><code>MAX_PRIORITY</code></td><td align="center">10</td></tr><tr><td align="left"><code>static int</code></td><td align="left"><code>MIN_PRIORITY</code></td><td align="center">5</td></tr><tr><td align="left"><code>static int</code></td><td align="left"><code>NORM_PRIORITY</code></td><td align="center">1</td></tr></tbody></table><p>获取线程的优先级：<code>int</code>  <code>getPriority()</code></p><p>设置线程的优先级：<code>void``setPriority(int newPriority)</code></p><p>线程优先级实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gzy.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Priority</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                System.out.println(getName()+<span class="string">",优先级： "</span>+getPriority()+<span class="string">" ,"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Priority a=<span class="keyword">new</span> Priority();</span><br><span class="line">        Priority b=<span class="keyword">new</span> Priority();</span><br><span class="line">        <span class="comment">//输出三个线程的优先级</span></span><br><span class="line"><span class="comment">/*        System.out.println(Thread.currentThread().getName()+","+"priority:"+Thread.currentThread().getPriority());</span></span><br><span class="line"><span class="comment">        System.out.println(a.getName()+","+"priority:"+a.getPriority());</span></span><br><span class="line"><span class="comment">        System.out.println(b.getName()+","+"priority:"+b.getPriority());*/</span></span><br><span class="line">        a.setPriority(a.MAX_PRIORITY);</span><br><span class="line">        b.setPriority(b.MIN_PRIORITY);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(四)、创建多线程的方式二：实现Runnable接口</strong></p><p>步骤：</p><ol><li>创建实现了Runnable接口的类</li><li>实现Runnable中的抽象方法：run()</li><li>创建实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li><li>通过Thread类的对象调用start()</li></ol><p>用<code>Runnable</code>接口创建线程实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gzy.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplementRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" :"</span>+num--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ImplementRunnable runnable=<span class="keyword">new</span> ImplementRunnable();</span><br><span class="line">        Thread a=<span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread b=<span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：同样，上述方式实现的线程存在安全问题！执行结果如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/P-apa/imageRepo@2.0/blog_img/Java%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A82.png" alt="线程安全2"></p><p><strong>(五)、比较两种创建线程的两种方式</strong></p><p>开发中：优先选择实现Runnable接口的方式</p><p>原因：</p><ol><li>实现的方式没有类的单继承性的局限性；</li><li>实现的方式更适合来处理多个线程有共享数据的情况。</li></ol><p>联系：Thread类实现了Runnable接口；两种方式都需要重写run()，将线程要执行的逻辑声明在run()中。</p><h3 id="三、线程的生命周期"><a href="#三、线程的生命周期" class="headerlink" title="三、线程的生命周期"></a>三、线程的生命周期</h3><p>线程的五种状态：</p><ol><li>新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态；</li><li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源;</li><li>运行：当就绪的线程<strong>被调度</strong>并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能；</li><li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态。无法获取CPU的执行权</li><li>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/P-apa/imageRepo@3.0.0/blog_img/Java%E7%BA%BF%E7%A8%8B/java%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="java线程生命周期"></p><p>阻塞和中断的区别？</p><h3 id="四、线程的同步"><a href="#四、线程的同步" class="headerlink" title="四、线程的同步"></a>四、线程的同步</h3><h5 id="一-、线程的安全问题："><a href="#一-、线程的安全问题：" class="headerlink" title="(一)、线程的安全问题："></a>(一)、线程的安全问题：</h5><ul><li><p>多个线程执行的不确定性引起执行结果的不稳定；</p></li><li><p>多个线程对账本的<strong>共享</strong>，会造成操作的不完整性，会破坏数据；</p></li><li><p>一个线程对共享数据还未操作完，另一个线程也开始对共享数据进行操作。</p></li></ul><h5 id="二-、方式一：同步代码"><a href="#二-、方式一：同步代码" class="headerlink" title="(二)、方式一：同步代码"></a>(二)、方式一：同步代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gzy.Thread.Synchronize;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">问题：买票过程中出现重票和错票的情况--&gt;出现了线程的安全问题</span></span><br><span class="line"><span class="comment">原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程也参与进来操作车票。</span></span><br><span class="line"><span class="comment">如何解决：当一个线程a操作共享数据时，其他线程不能参与进来，直到线程a操作完共享数据时，其他线程才可以操作共享数据。</span></span><br><span class="line"><span class="comment">在Java中通过同步机制来解决线程安全问题</span></span><br><span class="line"><span class="comment">方法一：同步代码块---&gt;不能包含代码多了，也不能包含代码少了</span></span><br><span class="line"><span class="comment">synchronized(同步监视器)&#123;</span></span><br><span class="line"><span class="comment">    需要同步的代码---操作共享数据的代码</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">同步监视器：即“锁”。任何一个类的对象都可以充当锁。但要求多个线程必须共用一把锁。</span></span><br><span class="line"><span class="comment">局限：操作同步代码时只能有一个线程参与，其他线程等待。相当于一个单线程过程，效率低；可能导致死锁。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法二：同步方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Windows</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">//Thread类实现</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> tickts=<span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Windows<span class="class">.<span class="keyword">class</span>) </span>&#123;<span class="comment">//含义：Class clazz=new Windows.class,Windows.class只会加载一次</span></span><br><span class="line">                <span class="keyword">if</span> (tickts &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(currentThread().getName() + <span class="string">":"</span> + tickts);</span><br><span class="line">                    tickts--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//        Windows w1=new Windows();</span></span><br><span class="line"><span class="comment">//        w1.setName("窗口1");</span></span><br><span class="line"><span class="comment">//        Windows w2=new Windows();</span></span><br><span class="line"><span class="comment">//        w2.setName("窗口2");</span></span><br><span class="line"><span class="comment">//        w1.start();</span></span><br><span class="line"><span class="comment">//        w2.start();</span></span><br><span class="line">        Windows2 windows2=<span class="keyword">new</span> Windows2();</span><br><span class="line">        Thread t3=<span class="keyword">new</span> Thread(windows2);</span><br><span class="line">        t3.setName(<span class="string">"窗口三"</span>);</span><br><span class="line">        Thread t4=<span class="keyword">new</span> Thread(windows2);</span><br><span class="line">        t4.setName(<span class="string">"窗口四"</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Windows2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;<span class="comment">//Thread继承方式不能用this关键字</span></span><br><span class="line">                <span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">",票数为："</span>+tickets);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="三-、方式二：同步方法"><a href="#三-、方式二：同步方法" class="headerlink" title="(三)、方式二：同步方法"></a>(三)、方式二：同步方法</h5><p>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明为同步的。</p><ol><li>使用同步方法实现Runnable接口的线程安全问题</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gzy.Thread.Synchronize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-10-18</span></span><br><span class="line"><span class="comment"> * 使用同步方法实现Runnable接口的线程安全问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowsTest3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="comment">//同步方法。此时同步件事器为this</span></span><br><span class="line">        <span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">",票数为："</span>+tickets);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用同步方法实现继承Thread类的线程安全问题</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gzy.Thread.Synchronize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-10-18</span></span><br><span class="line"><span class="comment"> * 使用同步方法实现继承Thread类的线程安全问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 关于同步方法的总结：</span></span><br><span class="line"><span class="comment"> * 1.同步方法仍然涉及到同步件事器，只是不需要显示声明</span></span><br><span class="line"><span class="comment"> * 2.非静态的同步方法，同步件事器是this</span></span><br><span class="line"><span class="comment"> *   静态的同步的方法，同步监视器是当前类本身</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowsTest4</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">//Thread类实现</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> tickts=<span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        WindowsTest4 w1=<span class="keyword">new</span> WindowsTest4();</span><br><span class="line">        w1.setName(<span class="string">"窗口1"</span>);</span><br><span class="line">        WindowsTest4 w2=<span class="keyword">new</span> WindowsTest4();</span><br><span class="line">        w2.setName(<span class="string">"窗口2"</span>);</span><br><span class="line">        w1.start();</span><br><span class="line">        w2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="comment">//同步件事器为WindowsTest4.class--正确</span></span><br><span class="line"><span class="comment">//    private synchronized void show()&#123;//此时，同步件事器为t1,t2--错误</span></span><br><span class="line">            <span class="keyword">if</span> (tickts &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + tickts);</span><br><span class="line">                tickts--;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="四-、线程的死锁问题"><a href="#四-、线程的死锁问题" class="headerlink" title="(四)、线程的死锁问题"></a>(四)、线程的死锁问题</h5><p>死锁的概念：</p><p>死锁示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gzy.Thread.DeadLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-10-18</span></span><br><span class="line"><span class="comment"> * 死锁举例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        StringBuffer s1=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">        StringBuffer s2=<span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (s1)&#123;</span><br><span class="line">                    s1.append(<span class="string">"a"</span>);</span><br><span class="line">                    s2.append(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (s2)&#123;</span><br><span class="line">                        s1.append(<span class="string">"b"</span>);</span><br><span class="line">                        s2.append(<span class="string">"2"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (s2)&#123;</span><br><span class="line">                    s1.append(<span class="string">"c"</span>);</span><br><span class="line">                    s2.append(<span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (s1)&#123;</span><br><span class="line">                        s1.append(<span class="string">"d"</span>);</span><br><span class="line">                        s2.append(<span class="string">"4"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（五）、方式三：Lock方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gzy.Thread.DeadLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-10-19</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 解决线程安全问题的方式三：lock锁---JDK5.0新增</span></span><br><span class="line"><span class="comment"> * synchronized与lock的异同？</span></span><br><span class="line"><span class="comment"> * 同：解决</span></span><br><span class="line"><span class="comment"> * 异：synchronized方法在执行完相应的同步代码以后，自动释放同步件事器</span></span><br><span class="line"><span class="comment"> *     lock需要手动的启动同步（lock()），同时，结束同步也需要手动的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Windows5 windows5=<span class="keyword">new</span> Windows5();</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(windows5);</span><br><span class="line">        t1.setName(<span class="string">"窗口5-1"</span>);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(windows5);</span><br><span class="line">        t2.setName(<span class="string">"窗口5-2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Windows5</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets=<span class="number">100</span>;</span><br><span class="line">    <span class="comment">//实例化lock</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//锁定方法</span></span><br><span class="line">                lock.lock();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">",票数为："</span>+tickets);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//调用解锁方法</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、线程的通信"><a href="#五、线程的通信" class="headerlink" title="五、线程的通信"></a>五、线程的通信</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadCommunication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gzy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 线程通信例子：使用两个线程交替打印1-100内的整数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 涉及到的三个方法：</span></span><br><span class="line"><span class="comment"> * wait():一旦执行此方法，当前线程进入阻塞状态，并释放同步件事器。</span></span><br><span class="line"><span class="comment"> * notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程，就唤醒优先级高的。</span></span><br><span class="line"><span class="comment"> * notifyAll():一旦执行此方法，就会唤醒被wait的所有线程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * 1.wait()、notify()、notifyAll()三个方法必须使用在同步代码块或同步方法中。</span></span><br><span class="line"><span class="comment"> * 2.wait()、notify()、notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步件事器</span></span><br><span class="line"><span class="comment"> *   否则会出现异常。</span></span><br><span class="line"><span class="comment"> * 3.wait()、notify()、notifyAll()三个方法定义在java.lang.Object类中。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 面试题：sleep()和wait()的异同？</span></span><br><span class="line"><span class="comment"> 同：执行这两种方法都会使当前线程进入阻塞状态。</span></span><br><span class="line"><span class="comment"> 异：声明的位置不同；调用要求不同；是否释放同步件事器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommunicationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        PrintNum p1=<span class="keyword">new</span> PrintNum();</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(p1);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(p1);</span><br><span class="line">        t1.setName(<span class="string">"线程1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"线程2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintNum</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number=<span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.notify();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (number&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">": "</span>+number--);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、JDK5-0新增线程创建方式"><a href="#六、JDK5-0新增线程创建方式" class="headerlink" title="六、JDK5.0新增线程创建方式"></a>六、JDK5.0新增线程创建方式</h3><h5 id="新增方式一：实现Callable接口"><a href="#新增方式一：实现Callable接口" class="headerlink" title="新增方式一：实现Callable接口"></a>新增方式一：实现Callable接口</h5><p>与Runnable相比，Callable功能更强大些：</p><ul><li>相比run()，可以有返回值</li><li>方法可以抛异常</li><li>支持泛型的返回值</li><li>需要借助FutureTask类，比如获取返回结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程的方式三：实现Callable接口。 --- JDK 5.0新增</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？</span></span><br><span class="line"><span class="comment"> * 1. call()可以有返回值的。</span></span><br><span class="line"><span class="comment"> * 2. call()可以抛出异常，被外面的操作捕获，获取异常的信息</span></span><br><span class="line"><span class="comment"> * 3. Callable是支持泛型的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        NumThread numThread = <span class="keyword">new</span> NumThread();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            Object sum = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">"总和为："</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="新增方式一：使用线程池"><a href="#新增方式一：使用线程池" class="headerlink" title="新增方式一：使用线程池"></a>新增方式一：使用线程池</h5>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h2&gt;&lt;h3 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、基本概念&quot;&gt;&lt;/a&gt;一、基本概念&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;程序(&lt;code&gt;program&lt;/code&gt;):是为完成某一任务、用某种编程语言编写的指令集合。是一段&lt;strong&gt;静态&lt;/strong&gt;代码。&lt;/li&gt;
&lt;li&gt;进程(&lt;code&gt;process&lt;/code&gt;):是程序的一次执行过程，或是一个正在运行的程序。是一个&lt;strong&gt;动态&lt;/strong&gt;过程。&lt;/li&gt;
&lt;li&gt;线程(&lt;code&gt;thread&lt;/code&gt;):是一个程序内部的&lt;strong&gt;一条执行路径&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;并行:多个CPU同时执行多个任务。&lt;/li&gt;
&lt;li&gt;并发:一个CPU同时执行多个任务(比如，采用时间片的方式)。
    
    </summary>
    
    
      <category term="java" scheme="http://daofenglee.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://daofenglee.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯赛前复习</title>
    <link href="http://daofenglee.cn/2020/10/13/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%8D%E4%B9%A0/"/>
    <id>http://daofenglee.cn/2020/10/13/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-10-13T14:52:57.541Z</published>
    <updated>2020-10-14T15:48:02.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="蓝桥杯赛前复习"><a href="#蓝桥杯赛前复习" class="headerlink" title="蓝桥杯赛前复习"></a>蓝桥杯赛前复习</h1><p><strong>1、0-1背包</strong></p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/P-apa/imageRepo@3.0/blog_img/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%8D%E4%B9%A0/0-1%E8%83%8C%E5%8C%85.png" alt="0-1背包"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n,W;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] w,v;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] dp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n=in.nextInt();W=in.nextInt();</span><br><span class="line">        w=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];v=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][W+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            w[i]=in.nextInt();</span><br><span class="line">            v[i]=in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        Knap();</span><br><span class="line">        System.out.println(dp[n][W]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Knap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,r;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (r=<span class="number">0</span>;r&lt;=W;r++)</span><br><span class="line">            dp[<span class="number">0</span>][r]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//按行填写</span></span><br><span class="line">            <span class="keyword">for</span> (r=<span class="number">1</span>;r&lt;=W;r++)&#123;<span class="comment">//dp[i,r]表示在前i个物品中挑选总重量不超过r的物品，即i表示物品个数，r表示此时背包的容量</span></span><br><span class="line">                <span class="keyword">if</span> (r&lt;w[i])</span><br><span class="line">                    dp[i][r]=dp[i-<span class="number">1</span>][r];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][r]=Math.max(dp[i-<span class="number">1</span>][r],dp[i-<span class="number">1</span>][r-w[i]]+v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、完全背包</strong></p><p>问题描述：</p><p>已知:有一个容量为V的背包和N件物品，第i件物品的重量是weight[i]，收益是cost[i]。</p><p>条件:每种物品都有无限件，能放多少就放多少。</p><p>问题:在不超过背包容量的情况下，最多能获得多少价值或收益</p><p>举例：物品个数N = 3，背包容量为V = 5，则背包可以装下的最大价值为40.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*方法1：转换为0-1背包问题</span></span><br><span class="line"><span class="comment">因为背包的容量有限，即使是只装一件物品，那么装的件数k最大为V(背包容量)/w(该物品的重量)。这里就将无限的转换为有限的了。同时，将同一件物品看成不同的物品，当然原来的物品件数也会相应增加。这就转换成了0-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//代码略</span></span><br><span class="line"><span class="comment">/*方法2：迭代方程： f[v] = max(f[v],f[v - weight[i]] + Value[i])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] f=<span class="keyword">new</span> <span class="keyword">int</span>[V+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Completeknapsack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=weight[i];v&lt;=V;v++)&#123;</span><br><span class="line">        f[v]=Math.max(f[v],f[v-weight[i]]+value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> f[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、多重背包</strong></p><p><strong>4、计算日期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.计算星期数</span></span><br><span class="line"><span class="comment">//吉姆拉尔森公式</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">weekdays</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> m,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m==<span class="number">1</span>||m==<span class="number">2</span>)&#123;</span><br><span class="line">            m+=<span class="number">12</span>;</span><br><span class="line">            y--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> w=(d+<span class="number">2</span>*m+<span class="number">3</span>*(m+<span class="number">1</span>)/<span class="number">5</span>+y+y/<span class="number">4</span>-y/<span class="number">100</span>+y/<span class="number">400</span>)%<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">return</span> ++w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> y=in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m=in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> d=in.nextInt();</span><br><span class="line">        System.out.println( weekdays(y,m,d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">利用基准日期：(w+totaldays-1)%7+1，计算结果取值为(1~7)。w是基准日期的星期数(取值为1~7)，totaldays是自基准日期到给定日期的天数。给定日期在基准日期之前：((w-totaldays-1)%7+7)%7+1。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>5、含有重复数字的全排列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求数组必须有序，所以在调用函数前必须排序</span></span><br><span class="line"><span class="comment">//小于等于10（值不相同）耗时小于1s，11时就大于1秒</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//全排列</span></span><br><span class="line">        n=<span class="number">4</span>;</span><br><span class="line">        numbers= <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>, <span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        ans=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        vis=<span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//含重复数字的全排列</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] numbers,ans;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] vis;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;n)&#123;</span><br><span class="line">            display();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> last=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="keyword">false</span>&amp;&amp;numbers[i]!=last)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i]=<span class="keyword">true</span>;</span><br><span class="line">                ans[k]=numbers[i];</span><br><span class="line">                last=numbers[i];</span><br><span class="line">                dfs(k+<span class="number">1</span>);</span><br><span class="line">                vis[i]=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            System.out.print(ans[i]);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、将数字转换为字符串的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//method1:</span></span><br><span class="line">String str1=<span class="string">""</span>+a;</span><br><span class="line">String str2=String.ValueOf(a);</span><br><span class="line">String str3=(String)a;</span><br></pre></td></tr></table></figure><p><strong>7、BigInteger、BigDecimal</strong></p><p><strong>8、拓展欧几里得算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x, y;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span>; </span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a%b);</span><br><span class="line">    <span class="keyword">int</span> t = y;</span><br><span class="line">    y = x - a/b*y;</span><br><span class="line">    x = t; </span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>9、Dijkstra算法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/P-apa/imageRepo@3.0/blog_img/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%8D%E4%B9%A0/Dijkstra.png" alt="Dijkstra"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dijkstra算法, Description : 贪心, O(N^2), 不能有负权</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dis,S;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n,x;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] w;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Arrays.fill(dis, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        dis[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">// 循环n次， 每次找出一个离起点最近的点。</span></span><br><span class="line">            <span class="keyword">int</span> t = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(S[j] == <span class="number">0</span> &amp;&amp; (t == -<span class="number">1</span> || dis[t] &gt; dis[j]))&#123; <span class="comment">// 找到一个距离最短的加入S集合。</span></span><br><span class="line">                    t = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            S[t] = <span class="number">1</span>;  <span class="comment">// 然后通过这个点来缩短原点到达其他点的距离。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                dis[j] = Math.min(dis[j], dis[t] + w[t][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dis[n] != <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> dis[n];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        n=<span class="number">6</span>;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        dis=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        S=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        w=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=n; i++)</span><br><span class="line">            Arrays.fill(w[i], <span class="number">0x3f3f3f3f</span>);</span><br><span class="line"></span><br><span class="line">        w[<span class="number">1</span>][<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line">        w[<span class="number">1</span>][<span class="number">5</span>]=<span class="number">30</span>;</span><br><span class="line">        w[<span class="number">1</span>][<span class="number">6</span>]=<span class="number">100</span>;</span><br><span class="line">        w[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">5</span>;</span><br><span class="line">        w[<span class="number">3</span>][<span class="number">4</span>]=<span class="number">50</span>;</span><br><span class="line">        w[<span class="number">4</span>][<span class="number">6</span>]=<span class="number">10</span>;</span><br><span class="line">        w[<span class="number">5</span>][<span class="number">6</span>]=<span class="number">60</span>;</span><br><span class="line">        w[<span class="number">5</span>][<span class="number">4</span>]=<span class="number">20</span>;</span><br><span class="line">        Dijkstra();</span><br><span class="line">        System.out.println(dis[<span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>10、Prime算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Arrays.fill(dis, <span class="number">0x3f3f3f3f</span>); <span class="comment">//设所有边距离边集的的距离为正无穷，也就是设所有边的状态为不可查找</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">// 存储最小生成树的总边权</span></span><br><span class="line">        dis[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 设1号点距离边集的距离为0；dis[j]表示节点j到生成树节点的距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;<span class="comment">// 循环n次</span></span><br><span class="line">            <span class="keyword">int</span> t = -<span class="number">1</span>;    </span><br><span class="line">            <span class="keyword">int</span> minv = INF; <span class="comment">//存储最短边</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;<span class="comment">//每循环n次，从未加入最小生成树的节点中选出离最小生成树点集最近的节点</span></span><br><span class="line">                <span class="keyword">if</span>(st[j] == <span class="number">0</span> &amp;&amp; minv &gt; dis[j])&#123;</span><br><span class="line">                    t = j;</span><br><span class="line">                    minv = dis[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(minv == INF) <span class="keyword">return</span> INF;<span class="comment">// 最短边是无穷大，说明该图不连通</span></span><br><span class="line">            res += dis[t];</span><br><span class="line">            st[t] = <span class="number">1</span>;</span><br><span class="line">           <span class="comment">//将t的邻接边的状态更新为待查找</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="comment">// 或者说是缩短t的邻接点到达边集的距离    </span></span><br><span class="line">                dis[j] = Math.min(dis[j], g[t][j]); </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>11、快速幂</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="comment">//求 a^b</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>; <span class="comment">// res保存结果</span></span><br><span class="line"><span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123; <span class="comment">//如果k的二进制数的最后一位是 1。 比如1011 &amp; 1 = 1</span></span><br><span class="line">res = (res * a) % mod;<span class="comment">//取模， 防止结果溢出。</span></span><br><span class="line">&#125;</span><br><span class="line">a = a * a % mod;<span class="comment">//得到 a^1, a^2, a^4, a^8, .....</span></span><br><span class="line">b = b &gt;&gt; <span class="number">1</span>; <span class="comment">//将b右移一位，去掉最低位。为了开始判断下一位。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>12、矩阵乘法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">matix_mul</span><span class="params">(<span class="keyword">long</span>[][] a, <span class="keyword">long</span>[][] b, <span class="keyword">long</span>[][] c)</span></span>&#123; <span class="comment">// c = a * b</span></span><br><span class="line"><span class="keyword">long</span>[][] t = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;; <span class="comment">// 中间数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">t[i][j] = (t[i][j] + (a[i][k]*b[k][j]) % mod)%mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) c[i] = Arrays.copyOf(t[i], <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;蓝桥杯赛前复习&quot;&gt;&lt;a href=&quot;#蓝桥杯赛前复习&quot; class=&quot;headerlink&quot; title=&quot;蓝桥杯赛前复习&quot;&gt;&lt;/a&gt;蓝桥杯赛前复习&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、0-1背包&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://daofenglee.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://daofenglee.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="蓝桥杯" scheme="http://daofenglee.cn/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>模拟进程并发执行</title>
    <link href="http://daofenglee.cn/2020/10/13/%E6%A8%A1%E6%8B%9F%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C/"/>
    <id>http://daofenglee.cn/2020/10/13/%E6%A8%A1%E6%8B%9F%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C/</id>
    <published>2020-10-13T05:37:43.812Z</published>
    <updated>2020-10-13T05:39:52.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模拟进程并发执行"><a href="#模拟进程并发执行" class="headerlink" title="模拟进程并发执行"></a>模拟进程并发执行</h1><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exp1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimulateConcurrence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        theFrame test=<span class="keyword">new</span> theFrame();</span><br><span class="line">        test.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<span class="comment">//框架关闭时退出程序</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            test.t1.run();</span><br><span class="line">            test.t2.run();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//窗体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">theFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  thePanel1 thePanel1=<span class="keyword">new</span> thePanel1(<span class="number">1</span>,<span class="string">"E:\\Users\\gzy\\Desktop\\照片\\OS\\1.jpg"</span>);</span><br><span class="line">    <span class="keyword">public</span>  thePanel1 thePanel2=<span class="keyword">new</span> thePanel1(<span class="number">2</span>,<span class="string">"E:\\Users\\gzy\\Desktop\\照片\\OS\\2.jpg"</span>);</span><br><span class="line">    <span class="keyword">private</span> Container con=getContentPane();<span class="comment">//创建一个容器</span></span><br><span class="line">    Thread t1=<span class="keyword">new</span> Thread(thePanel1);</span><br><span class="line">    Thread t2=<span class="keyword">new</span> Thread(thePanel2);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">theFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"模拟进程的并发执行"</span>);</span><br><span class="line">        setSize(<span class="number">800</span>,<span class="number">800</span>);</span><br><span class="line">        setLocationRelativeTo(<span class="keyword">null</span>);<span class="comment">//把窗口位置设置到屏幕中心</span></span><br><span class="line">        GridLayout gridLayout=<span class="keyword">new</span> GridLayout(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        con.setLayout(gridLayout);</span><br><span class="line">        con.add(thePanel1);</span><br><span class="line">        con.add(thePanel2);</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thePanel1</span> <span class="keyword">extends</span> <span class="title">JPanel</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JLabel jLabel=<span class="keyword">new</span> JLabel();<span class="comment">//添加标签</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">500</span>;<span class="comment">//用来控制其窗体的y坐标</span></span><br><span class="line"></span><br><span class="line">    JButton stop,start;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    String url;<span class="comment">//绝对路径</span></span><br><span class="line">    Icon icon;</span><br><span class="line"></span><br><span class="line">    thePanel1(<span class="keyword">int</span> i,String url)&#123;</span><br><span class="line"></span><br><span class="line">        setLayout(<span class="keyword">null</span>);</span><br><span class="line">        setBorder(BorderFactory.createTitledBorder(<span class="string">"模拟进程"</span>+i));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.url=url;</span><br><span class="line">        <span class="keyword">this</span>.icon=<span class="keyword">new</span> ImageIcon(url);</span><br><span class="line"></span><br><span class="line">        jLabel.setIcon(icon);</span><br><span class="line">        jLabel.setBounds(<span class="number">100</span>,<span class="number">50</span>,<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">        jLabel.setHorizontalAlignment(SwingConstants.LEFT);<span class="comment">//让其在最左边显示</span></span><br><span class="line">        jLabel.setOpaque(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        stop=<span class="keyword">new</span> JButton(<span class="string">"暂停"</span>);</span><br><span class="line">        start=<span class="keyword">new</span> JButton(<span class="string">"开始"</span>);</span><br><span class="line">        stop.setBounds(<span class="number">100</span>,<span class="number">700</span>,<span class="number">70</span>,<span class="number">35</span>);</span><br><span class="line">        start.setBounds(<span class="number">300</span>,<span class="number">700</span>,<span class="number">70</span>,<span class="number">35</span>);</span><br><span class="line">        add(stop);</span><br><span class="line">        add(start);</span><br><span class="line">        add(jLabel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent actionEvent)</span> </span>&#123;</span><br><span class="line">                flag=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        start.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent actionEvent)</span> </span>&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">0</span> &amp;&amp; flag==<span class="keyword">true</span>)&#123;</span><br><span class="line">            jLabel.setBounds(<span class="number">100</span>, count, <span class="number">200</span>, <span class="number">130</span>);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.currentThread().sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            count-=<span class="number">10</span>;<span class="comment">//每次循环自减的值</span></span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;<span class="comment">//当到达最上边时，设置count值在最下边</span></span><br><span class="line">                count=<span class="number">500</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模拟进程并发执行&quot;&gt;&lt;a href=&quot;#模拟进程并发执行&quot; class=&quot;headerlink&quot; title=&quot;模拟进程并发执行&quot;&gt;&lt;/a&gt;模拟进程并发执行&lt;/h1&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java异常处理机制</title>
    <link href="http://daofenglee.cn/2020/09/24/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://daofenglee.cn/2020/09/24/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</id>
    <published>2020-09-24T11:45:40.099Z</published>
    <updated>2020-09-27T14:04:03.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java异常处理机制"><a href="#Java异常处理机制" class="headerlink" title="Java异常处理机制"></a>Java异常处理机制</h1><h3 id="一、异常的概述"><a href="#一、异常的概述" class="headerlink" title="一、异常的概述"></a>一、异常的概述</h3><p>Java程序在执行过程中所发生的异常事件可分为两类：</p><ol><li><p><code>Error</code>：Java虚拟机无法解决的严重问题。如栈溢出，堆溢出(OutOfMemory)。需要改代码。</p></li><li><p><code>Exception</code>: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。比如：空指针访问、试图读取不存在的文件、网络连接中断、数组角标越界等。</p></li></ol><p>而我们说的异常通常指的是可以使用针对性的代码进行处理的异常，即<code>Exception</code>类异常。后面的内容也是对<code>Exception</code>类异常的讲解。</p><a id="more"></a><h3 id="二、Exception异常分类"><a href="#二、Exception异常分类" class="headerlink" title="二、Exception异常分类"></a>二、Exception异常分类</h3><p><strong>运行时异常</strong>：指编译器不强制处理的异常。一般是指编程的时逻辑错误。对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。</p><p><strong>编译时异常</strong>：编译器要求必须处理的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常。</p><h3 id="三、异常的体系结构及常见异常"><a href="#三、异常的体系结构及常见异常" class="headerlink" title="三、异常的体系结构及常见异常"></a>三、异常的体系结构及常见异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Throwable</span><br><span class="line">    |-----java.lang.Error:一般不编写针对性的代码进行处理。</span><br><span class="line">    |-----java.lang.Exception:可以进行异常的处理。</span><br><span class="line">        |-----编译时异常（checked）</span><br><span class="line">            |-----IOException</span><br><span class="line">                |-----FileNotFoundException</span><br><span class="line">                |-----EOFException</span><br><span class="line">            |-----ClassNotFoundException</span><br><span class="line">        |-----运行时异常（unchecked）</span><br><span class="line">            |-----NullPointerException</span><br><span class="line">            |-----ClassCastException（类型转换异常）</span><br><span class="line">            |-----ArithmeticException</span><br><span class="line">            |-----NumberFormatException</span><br><span class="line">            |-----InputMismatchException</span><br></pre></td></tr></table></figure><h3 id="四、异常处理机制"><a href="#四、异常处理机制" class="headerlink" title="四、异常处理机制"></a>四、异常处理机制</h3><p><strong>(一)、异常处理机制：“抓抛”模型</strong></p><p>过程一：“抛”<br>程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出。一旦抛出对象以后，此后的代码(try块内的)就不再执行。其中异常对象的生成有两种方式：(1)系统自动生成，(2)手动生成异常对象并抛出(<code>throw</code>，注意这里不是<code>throws</code>)</p><p>过程二：”抓”<br>可以理解为异常的处理方式：(2)try-catch-finally，(2)throws</p><p><strong>(二)、异常的第一种处理方式：try-catch-finally</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     <span class="comment">//可能出现异常的代码 </span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line">     <span class="comment">//处理异常的方式1</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line">     <span class="comment">//处理异常的方式2</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line">     <span class="comment">//处理异常的方式2</span></span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">     <span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li>finally是可选的；</li><li>使用try将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型去catch中进行匹配；</li><li>一旦try中的异常对象去配到某一个catch时，就进入catch中进行异常处理。一旦处理完成就跳出当前的try-catch结构（没有写finally的情况），继续执行其后的代码；</li><li>catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓；如果满足子父类关系，则要求子类一定声明在父类的上面，否则报错；</li><li>常用的异常处理方式：(1). <code>String getMessage()</code>,(2)<code>printStackTrace()</code></li><li>在try结构中声明的变量，出了try结构后就不能再被调用；</li><li>使用try-catch-finally处理编译时异常，使得程序在编译时不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时的异常延迟到运行时出现；</li><li>在开发中，由于运行时异常比较常见，所以通常我们就不针对运行时异常编写try-catch-finally。针对编译时异常，一定要考虑异常的处理。</li></ol><p>(三)、异常处理的第二种方式：throws+异常类型</p><ol><li><p>“throws+异常类型”写在方法声明处。指出该方法在执行时可能会抛出的异常类型。一旦当方法体执行时出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws语句后的异常类型时，就会被抛出。<strong>异常代码后续的代码，就不再执行！</strong></p></li><li><p>try-catch-finally的方式真正地将异常给处理掉了；而throws的方式只是将异常抛给了方法的调用者，并没有真正将异常处理掉。</p></li><li><p>开发中如何选择使用try-catch-finally 还是使用throws？</p></li></ol><ul><li>如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。<ul><li>执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。</li></ul></li></ul><h3 id="五、异常方法重写"><a href="#五、异常方法重写" class="headerlink" title="五、异常方法重写"></a>五、异常方法重写</h3><p>方法重写的规则之一：子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">OverrideTest test = <span class="keyword">new</span> OverrideTest();</span><br><span class="line">test.display(<span class="keyword">new</span> SubClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(SuperClass s)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">s.method();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span><span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、手动抛出异常：throw"><a href="#六、手动抛出异常：throw" class="headerlink" title="六、手动抛出异常：throw"></a>六、手动抛出异常：throw</h3><p>手动抛出异常是相对于系统自动抛出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">s.regist(-<span class="number">1001</span>);</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regist</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//手动抛出异常对象</span></span><br><span class="line">            <span class="comment">//  throw new RuntimeException("您输入的数据非法！");</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"您输入的数据非法！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Student [id="</span> + id + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、自定义异常类"><a href="#七、自定义异常类" class="headerlink" title="七、自定义异常类"></a>七、自定义异常类</h3><p>步骤：</p><ol><li>继承于现有的异常结构：<code>RuntimeException</code> 、<code>Exception</code></li><li>提供全局常量：serialVersionUID</li><li>提供重载的构造器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7034897193246939L</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h3><p>这里学的异常处理并不是解决异常的根本方法，而是将可能出现的异常以一种”友好”的方式展现出来。比如用户点击了一个按钮，此时代码出现了异常，如果不针对这个异常进行处理的话可能展示出来的就是一段乱码或程序直接闪退；而进行异常处理就可用对话框的形式向用户发出错误提示信息，也可以将这个错误信息发送到后台，供开发人员进行修改。<br>而对于异常根本的解决方法就是修改代码，解决这个异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java异常处理机制&quot;&gt;&lt;a href=&quot;#Java异常处理机制&quot; class=&quot;headerlink&quot; title=&quot;Java异常处理机制&quot;&gt;&lt;/a&gt;Java异常处理机制&lt;/h1&gt;&lt;h3 id=&quot;一、异常的概述&quot;&gt;&lt;a href=&quot;#一、异常的概述&quot; class=&quot;headerlink&quot; title=&quot;一、异常的概述&quot;&gt;&lt;/a&gt;一、异常的概述&lt;/h3&gt;&lt;p&gt;Java程序在执行过程中所发生的异常事件可分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Error&lt;/code&gt;：Java虚拟机无法解决的严重问题。如栈溢出，堆溢出(OutOfMemory)。需要改代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Exception&lt;/code&gt;: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。比如：空指针访问、试图读取不存在的文件、网络连接中断、数组角标越界等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而我们说的异常通常指的是可以使用针对性的代码进行处理的异常，即&lt;code&gt;Exception&lt;/code&gt;类异常。后面的内容也是对&lt;code&gt;Exception&lt;/code&gt;类异常的讲解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://daofenglee.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://daofenglee.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>DFS算法的学习</title>
    <link href="http://daofenglee.cn/2020/09/17/DFS%E7%AE%97%E6%B3%95/"/>
    <id>http://daofenglee.cn/2020/09/17/DFS%E7%AE%97%E6%B3%95/</id>
    <published>2020-09-16T16:37:59.668Z</published>
    <updated>2020-09-24T11:44:09.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DFS算法的学习"><a href="#DFS算法的学习" class="headerlink" title="DFS算法的学习"></a>DFS算法的学习</h1><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a><strong>简述</strong></h3><p>首先，DFS (Depth First Search) 是一种在程序设计竞赛中常用的搜索算法。那么，什么是搜索？搜索可以是在众多数据中找到符合要求的一组数据；也可以是寻找一条从某一起点到目标终点的最佳路径。在这过程中可能会不断作出尝试性的选择来达到访问全局，最终得出结果。</p><a id="more"></a><h3 id="DFS算法思想"><a href="#DFS算法思想" class="headerlink" title="DFS算法思想"></a><strong>DFS算法思想</strong></h3><p>这有类问题在求解时需要一定的步骤。通常求解这些问题采取的策略是:从起始位置(或起始状态)出发，试探性的选择一个可行的步骤到达下一个状态， 而后又从这个状态出发选择一个可 行的步骤达到下一个状态 ……每到达 一个状态如果发现没有可行的步骤则回退到上一步，再试探其他可行的步骤;如果回退到上一步依然没有其他可行的步骤，则继续回退到再上一步;如此反复直到目标位置(或目标状态)，或者所有状态都访问完后还没有找到目标状态，则说明无解。</p><p>在图论中，深度优先遍历主要思路是从图中⼀个未访问的顶点 V 开始，沿着⼀条路⼀直⾛到底，然后从这条路尽头的节点回退到上⼀个节点，再从另⼀条路开始⾛到底……不断递归重复此过程，直到所有的顶点都遍历完成，它的特点是不撞南墙不回头，先⾛完⼀条路，再换⼀条路继续⾛。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a><strong>关键字</strong></h3><p>尝试性选择；回退；递归；当前状态；下一状态</p><h3 id="例题讲解"><a href="#例题讲解" class="headerlink" title="例题讲解"></a><strong>例题讲解</strong></h3><p>接下来通过三道题来理解DFS算法，三道题分别对应于三中不同的场景（矩阵、一位数组和二叉树）。</p><p><strong><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827365609" target="_blank" rel="noopener">1.骨头的诱惑</a></strong></p><p>题目来源：ZOJ2110</p><p>题目描述：<br>    一只小狗在一个古老的迷宫里找到一根骨头，当它叼起骨头时，迷宫开始颤抖，它感觉到地面开始下沉。它才明白骨头是一个陷阱，它拼命地试着逃出迷宫。<br>    迷宫是一个N×M 大小的长方形，迷宫有一个门。刚开始门是关着的，并且这个门会在第T 秒钟开启，门只会开启很短的时间（少于一秒），因此小狗必须恰好在第T 秒达到门的位置。每秒钟，它可以向上、下、左或右移动一步到相邻的方格中。但一旦它移动到相邻的方格，这个方格开始下沉，而且会在下一秒消失。所以，它不能在一个方格中停留超过一秒，也不能回到经过的方格。小狗能成功逃离吗？请你帮助他。<br>输入描述：<br>    输入文件包括多个测试数据。每个测试数据的第一行为三个整数：N,M,T，(1&lt;N, M&lt;7；0&lt;T&lt;50)，分别代表迷宫的长和宽，以及迷宫的门会在第T 秒时刻开启。接下来N 行信息给出了迷宫的格局，每行有M 个字符，这些字符可能为如下值之一：<br>    X: 墙壁，小狗不能进入 S: 小狗所处的位置<br>    D: 迷宫的门 . : 空的方格<br>    输入数据以三个0 表示输入数据结束。<br>输出描述：<br>    对每个测试数据，如果小狗能成功逃离，则输出”YES”，否则输出”NO”。</p><p>样例输入：<br>    3 4 5<br>    S . . .<br>    . X . X<br>    . . . D<br>    4 4 8<br>    . X . X<br>    . . S .<br>    . . . .<br>    D X . X<br>    4 4 5<br>    S . X .<br>    . . X .<br>    . . X D<br>    . . . .<br>    0 0 0</p><p>样例输出：</p><p>YES<br>YES<br>NO</p><p><strong>题目解析</strong><br>                略<br><strong>核心代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m,n,T,X,Y;<span class="comment">//m,n是矩阵的大小;T是第t秒到达;X,Y是终点坐标</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> matrix[m][n];<span class="comment">//迷宫矩阵</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> falg=<span class="keyword">false</span>;<span class="comment">//flag为true则成功逃离，false则没有</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[][] V=&#123;-<span class="number">1</span>,<span class="number">0</span>;<span class="number">0</span>,-<span class="number">1</span>;<span class="number">1</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">1</span>&#125;;<span class="comment">//用来表示上左下右四个方向</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="comment">//下面两个if语句是递归的结束条件，即遇到边界、找到答案</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=m||y&lt;<span class="number">0</span>||y&gt;=n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==X&amp;&amp;y==Y&amp;&amp;t==T)&#123;</span><br><span class="line">        flag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下是按上、左、下、右的顺序进行访问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[x+V[i][<span class="number">0</span>]][y+V[i][<span class="number">1</span>]]==<span class="string">'X'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        matrix[x][y]=<span class="string">'X'</span>;<span class="comment">//将空白处变为墙壁</span></span><br><span class="line">        DFS(x+V[i][<span class="number">0</span>],y+V[i][<span class="number">1</span>],t+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        matrix[x][y]=<span class="string">'.'</span>;<span class="comment">//回退</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a href="http://poj.org/problem?id=1011" target="_blank" rel="noopener">2.小木棍</a></strong></p><p>Description</p><p>乔治拿来一组等长的木棒，将它们随机地砍断，使得每一节木棍的长度都不超过50个长度单位。然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。请你设计一个程序，帮助乔治计算木棒的可能最小长度。每一节木棍的长度都用大于零的整数表示。</p><p>Input</p><p>输入包含多组数据，每组数据包括两行。第一行是一个不超过64的整数，表示砍断之后共有多少节木棍。第二行是截断以后，所得到的各节木棍的长度。在最后一组数据之后，是一个零。</p><p>Output</p><p>为每组数据，分别输出原始木棒的可能最小长度，每组数据占一行。</p><p>Sample Input</p><p>9<br>        5 2 1 5 2 1 5 2 1<br>        4<br>        1 2 3 4<br>        0</p><p>Sample Output</p><p>6<br>        5</p><p>题目要求木棒的最小长度，根据题目可知，木棒的最小长度应该不小于小木棍中最长的那一根的长度。以样例中第二组数据为例，先将小木棍的按有长到短进行排序，即4 3 2 1，假设木棒的长度为4，则组合为4;3,1;2,2!=4，不符合，此时设木棒的长度5，则可以得到组合4,1;3,2，符合题目要求，即最短长度为5。</p><p>样例的第一组数据则要麻烦些，排序后为5 5 5 2 2 21 1 1，</p><p><strong>关键代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pieceNum;    <span class="comment">//切割得到的小段总数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> stickLen;    <span class="comment">//小木棍的长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> stickNum;    <span class="comment">//小木棍的数目</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pieceLen[N];    <span class="comment">//小段的长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> isPieceUsed[N];    <span class="comment">//搜索过程中小段是否被使用</span></span><br><span class="line"><span class="comment">//正在拼接第filledStickNum根小木棍，已经得到的这根小木棍的长度filledLen</span></span><br><span class="line"><span class="comment">//选取小段时的起始编号（不用取编号在startNo之前的小段）</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">search</span><span class="params">( <span class="keyword">int</span> filledStickNum, <span class="keyword">int</span> filledLen, <span class="keyword">int</span> startNo )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( filledStickNum==stickNum )  <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">//存在满足要求的拼接方法</span></span><br><span class="line">    <span class="keyword">int</span> i, p;</span><br><span class="line">    <span class="keyword">for</span>( i=startNo; i&lt;pieceNum; i++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( isPieceUsed[i]==<span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="comment">//如果加入选取的小段之后，这根木棍还没有拼接完成</span></span><br><span class="line">            <span class="keyword">if</span>( (p=filledLen+pieceLen[i])&lt;stickLen ) &#123;</span><br><span class="line">                isPieceUsed[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>( search(filledStickNum,p,i+<span class="number">1</span>) )  <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">//剪枝1</span></span><br><span class="line">                isPieceUsed[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>( startNo==<span class="number">0</span> )  <span class="keyword">break</span>;    <span class="comment">//剪枝2</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( p==stickLen ) &#123;</span><br><span class="line">                isPieceUsed[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>( search(filledStickNum+<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>) )  <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">//剪枝1</span></span><br><span class="line">                isPieceUsed[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;    <span class="comment">//剪枝3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener"><strong>3.二叉树的最大深度</strong></a></p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><p><strong>关键代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> date;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> D,Node L,Node R)</span></span>&#123;</span><br><span class="line">        date=D;</span><br><span class="line">        left=L;</span><br><span class="line">        right=R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS3</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> L=DFS3(root.left)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> R=DFS3(root.right)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(L,R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener"> <strong>4.二叉树的最小深度</strong></a></p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回它的最小深度  2.</p><p><strong>关键代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS4</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+DFS4(root.right);</span><br><span class="line">    <span class="keyword">if</span> (root.right==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+DFS4(root.left);</span><br><span class="line">    <span class="keyword">int</span> L=<span class="number">1</span>+DFS4(root.left);</span><br><span class="line">    <span class="keyword">int</span> R=<span class="number">1</span>+DFS4(root.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+Math.min(L,R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;DFS算法的学习&quot;&gt;&lt;a href=&quot;#DFS算法的学习&quot; class=&quot;headerlink&quot; title=&quot;DFS算法的学习&quot;&gt;&lt;/a&gt;DFS算法的学习&lt;/h1&gt;&lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;首先，DFS (Depth First Search) 是一种在程序设计竞赛中常用的搜索算法。那么，什么是搜索？搜索可以是在众多数据中找到符合要求的一组数据；也可以是寻找一条从某一起点到目标终点的最佳路径。在这过程中可能会不断作出尝试性的选择来达到访问全局，最终得出结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://daofenglee.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://daofenglee.cn/tags/Java/"/>
    
      <category term="DFS" scheme="http://daofenglee.cn/tags/DFS/"/>
    
      <category term="算法" scheme="http://daofenglee.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://daofenglee.cn/2020/07/23/hello-world/"/>
    <id>http://daofenglee.cn/2020/07/23/hello-world/</id>
    <published>2020-07-23T09:51:57.809Z</published>
    <updated>2020-08-01T14:40:05.701Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="实验" scheme="http://daofenglee.cn/categories/%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="hexo" scheme="http://daofenglee.cn/tags/hexo/"/>
    
  </entry>
  
</feed>
