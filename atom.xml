<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宗沅のBLOG</title>
  
  <subtitle>一步一步往上爬的瓜牛</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://p-apa.github.io/"/>
  <updated>2020-02-02T05:27:01.748Z</updated>
  <id>http://p-apa.github.io/</id>
  
  <author>
    <name>宗沅</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浮点数在计算机中的存储</title>
    <link href="http://p-apa.github.io/2020/08/25/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/"/>
    <id>http://p-apa.github.io/2020/08/25/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/</id>
    <published>2020-08-25T08:00:35.397Z</published>
    <updated>2020-02-02T05:27:01.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题阐述"><a href="#问题阐述" class="headerlink" title="问题阐述"></a>问题阐述</h1><p>学习java时对float类型产生一些疑问：①在4个字节的存储空间里float的数值范围（-3.4E+38 至3.4E+38）是怎么计算来的；②计算机是如何存储小数的。在网上查看了许多博客文章和文献后大致弄清楚了这个问题。接下来我将通过介绍浮点数在计算机中的存储机制和实例来讲解这个问题。</p><a id="more"></a> <h1 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h1><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a><a href="https://www.runoob.com/w3cnote/decimal-decimals-are-converted-to-binary-fractions.html" target="_blank" rel="noopener">进制转换</a></h3><p>假如在写代码的时候定义了一个float变量并给它赋值，此时赋的值是十进制，而计算机是以二进制存储的，所以首先需要将十进制小数转化为二进制小数。</p><p>十进制数转换为二进制数时，由于整数和小数的转换方法不同，所以先将十进制数的整数部分和小数部分分别转换后，再加以合并。</p><p><strong>1.十进制整数转换为二进制整数</strong><br>十进制整数转换为二进制整数采用”除2取余，逆序排列”法。具体做法是：用2去除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为零时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。</p><p>例如把 (173)10 转换为二进制数。<br><img src="https://github.com/P-apa/imageRepo/raw/master/blog_1_Float-storage-in-computer/blog_1_picture_1.jpg" alt=""></p><p><strong>2．十进制小数转换为二进制小数</strong><br>十进制小数转换成二进制小数采用”乘2取整，顺序排列”法。具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。</p><p>然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。</p><p>例如把（0.8125）转换为二进制小数。<br><img src="https://github.com/P-apa/imageRepo/raw/master/blog_1_Float-storage-in-computer/blog_1_picture_2.jpg" alt=""></p><p>但是，不是所有的小数都能转换有限位数的二进制小数。例如10进制0.2的2进制：</p><p>0.2 x 2=0.4        0<br>0.4 x 2=0.8        0<br>0.8 x 2=1.6        1<br>0.6 x 2=1.2        1<br>0.2 x 2=0.4        0<br>0.4 x 2=0.8        0<br>0.8 x 2=1.6        1<br>0.6 x 2=1.2        1<br>……</p><p>发现了吗？它是乘不尽的，是无限循环（0011）的……</p><p>在计算机中，浮点数没有办法精确表示的根本原因在于计算机有限的内存无法表示无限的小数位。只能截断，<strong>截断就造精度的缺失</strong>。</p><p>0.2 的二进制小数表示可以是：</p><p>0.2 = 0.00110011</p><p>转为十进制为：1/8 + 1/16 + 1/128 + 1/256 = 0.19921875</p><p>已经很接近了，如果需要更精确的表示，只需要保留更长的有效位数。这也是双精度的double比单精度的float更精确的原因。</p><p>那计算机究竟是如何保存二进制小数的呢？这个就不得不提 IEEE 754 规范了。</p><h3 id="IEEE-754规范"><a href="#IEEE-754规范" class="headerlink" title="IEEE 754规范"></a>IEEE 754规范</h3><p>根据国际标准<a href="https://baike.baidu.com/item/IEEE%20754/3869922?fromtitle=IEEE754%E6%A0%87%E5%87%86&fromid=10427270" target="_blank" rel="noopener">IEEE 754</a>，任意一个二进制浮点数V可以表示成下面的形式：</p><p>　　</p><p>　　（1）(-1)^s^表示符号位，当s=0，V为正数；当s=1，V为负数。</p><p>　　（2）M表示有效数字，大于等于1，小于2。</p><p>　　（3）2^E^表示指数位。</p><p>举例来说，十进制的5.0，写成二进制是101.0，相当于1.01×2^2^。那么，按照上面V的格式，可以得出s=0，M=1.01，E=2。</p><p>十进制的-5.0，写成二进制是-101.0，相当于-1.01×2^2^。那么，s=1，M=1.01，E=2。</p><p>IEEE 754规定，对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。<br><img src="https://github.com/P-apa/imageRepo/raw/master/blog_1_Float-storage-in-computer/blog_1_picture_3.jpg" alt=""></p><p>对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。<br><img src="https://github.com/P-apa/imageRepo/raw/master/blog_1_Float-storage-in-computer/blog_1_picture_4.jpg" alt=""><br>IEEE 754对有效数字M和指数E，还有一些特别规定。</p><p>前面说过，1≤M&lt;2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。</p><p>至于指数E，情况就比较复杂。</p><p>首先，E为一个无符号整数（unsigned int）。这意味着，如果E为8位，它的取值范围为0 ~ 255；如果E为11位，它的取值范围为0 ~ 2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，E的真实值必须再减去一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。</p><p>比如，2^10^的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。</p><p>然后，指数E还可以再分成三种情况：</p><p>（1）E不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。</p><p>（2）E全为0。这时，浮点数的指数E等于1-127（或者1-1023），有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。</p><p>（3）E全为1。这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>上述就是浮点数大概的表示规则，详细请看<a href="https://baike.baidu.com/item/IEEE%20754/3869922?fromtitle=IEEE754%E6%A0%87%E5%87%86&fromid=10427270" target="_blank" rel="noopener">IEEE 754</a>。</p><p>浮点数9.0的二进制表示如下：<br>浮点数9.0的二进制为1001.0，即1.001×2^3^。<br>那么，第一位的符号位s=0，有效数字M等于001后面再加20个0，凑满23位，指数E等于3+127=130，即10000010。<br>所以，二进制形式为：0 10000010 001 0000 0000 0000 0000 0000。</p><p>float类型和double类型的取值范围计算如下：</p><p>对于单精度浮点数（float）来说，有一位符号位，指数位共8位，尾数共23位。指数能够表示的指数范围为-128~127。尾数为23位。当尾数全1时再加上小数点前面的1，指数取到最大正数127（8位，正数最大127，负数最小-128）,浮点数取得正数的最大值。<br>+1.111111111111111111111*2^127^（1.后面23个1，由于尾数的范围1～2，其最高位总为1，故只需存取小数部分，所以小数为是23位1），约等于2 * 2^127^=3.4 * 10^38^。为3.4 * 10^38^负数亦然。</p><p>Double的计算与此类似，double的符号位为63位，指数为62～52位，共11位。表示的范围为-1024～1023。尾数为51～0。表示的范围为+1.111111111111111111111*2^1023^（1.后面52个1）为1.7 * 10^308^。负数亦然。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题阐述&quot;&gt;&lt;a href=&quot;#问题阐述&quot; class=&quot;headerlink&quot; title=&quot;问题阐述&quot;&gt;&lt;/a&gt;问题阐述&lt;/h1&gt;&lt;p&gt;学习java时对float类型产生一些疑问：①在4个字节的存储空间里float的数值范围（-3.4E+38 至3.4E+38）是怎么计算来的；②计算机是如何存储小数的。在网上查看了许多博客文章和文献后大致弄清楚了这个问题。接下来我将通过介绍浮点数在计算机中的存储机制和实例来讲解这个问题。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://p-apa.github.io/2020/07/23/hello-world/"/>
    <id>http://p-apa.github.io/2020/07/23/hello-world/</id>
    <published>2020-07-23T09:51:57.809Z</published>
    <updated>2020-08-01T14:40:05.701Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="实验" scheme="http://P-apa.github.io/categories/%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="hexo" scheme="http://P-apa.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>&lt;&lt;java核心技术&gt;&gt; 5.7 反射机制笔记</title>
    <link href="http://p-apa.github.io/2020/03/13/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-5-7-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%AC%94%E8%AE%B0/"/>
    <id>http://p-apa.github.io/2020/03/13/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-5-7-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%AC%94%E8%AE%B0/</id>
    <published>2020-03-13T10:52:05.000Z</published>
    <updated>2020-03-13T11:32:37.283Z</updated>
    
    <content type="html"><![CDATA[<h5 id="什么是反射机制"><a href="#什么是反射机制" class="headerlink" title="什么是反射机制"></a>什么是反射机制</h5><p>“能分析类能力的程序称为反射（reflective）”，Horstmann如是说。通俗来说就是，通过编写一个程序来获取一个类有哪些域（filed）、方法（method）和构造器（constructor）来分析这个类是用来干什么的。</p><h5 id="反射机制的作用"><a href="#反射机制的作用" class="headerlink" title="反射机制的作用"></a>反射机制的作用</h5><p>、</p><h5 id="反射机制的初级使用"><a href="#反射机制的初级使用" class="headerlink" title="反射机制的初级使用"></a>反射机制的初级使用</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;什么是反射机制&quot;&gt;&lt;a href=&quot;#什么是反射机制&quot; class=&quot;headerlink&quot; title=&quot;什么是反射机制&quot;&gt;&lt;/a&gt;什么是反射机制&lt;/h5&gt;&lt;p&gt;“能分析类能力的程序称为反射（reflective）”，Horstmann如是说。通俗来说就是，通过
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java大数的简单使用</title>
    <link href="http://p-apa.github.io/2020/02/01/java%E5%A4%A7%E6%95%B0%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://p-apa.github.io/2020/02/01/java%E5%A4%A7%E6%95%B0%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2020-02-01T05:19:34.000Z</published>
    <updated>2020-02-06T09:49:41.229Z</updated>
    
    <content type="html"><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>　　如果基本的整数和浮点数精度不能够满足需求， 那么可以使用java.math 包中的两个很有用的类：Biglnteger 和 BigDecimaL 这两个类可以处理包含<strong>任意长度</strong>数字序列的数值。 Biglnteger类实现了<strong>任意精度</strong>的整数运算， BigDecimal 实现了任意精度的浮点数运算。 </p><a id="more"></a> <h4 id="1-java-math-BigInteger"><a href="#1-java-math-BigInteger" class="headerlink" title="1. java.math.BigInteger"></a>1. java.math.BigInteger</h4><p>常用操作：<br>• Biglnteger add(Biglnteger other)<br>• Biglnteger subtract(Biglnteger other)<br>• Biglnteger multipiy(Biginteger other)<br>• Biglnteger divide(Biglnteger other)<br>• Biglnteger mod(Biglnteger other)<br>返冋这个大整数和另一个大整数 other的和、差、 积、 商以及余数。<br>• int compareTo(Biglnteger other)<br>如果这个大整数与另一个大整数 other 相等， 返回 0; 如果这个大整数小于另一个大整 数 other, 返回负数； 否则， 返回正数。<br>• static Biglnteger valueOf(long x)<br>返回值等于 x 的大整数。 （静态函数valueOf的参数只能是long类型的）</p><p><strong><em>例1.1</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">   BigInteger a = BigInteger.valueOf(<span class="number">1234567891</span>);<span class="comment">//参数为long类型</span></span><br><span class="line">   BigInteger b = <span class="keyword">new</span> BigInteger(<span class="string">"1234567891011121314226587562147"</span>);<span class="comment">//将任意长度的字符串转换为大整数</span></span><br><span class="line">   BigInteger c = in.nextBigInteger();<span class="comment">//键盘输入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//四则简单运算</span></span><br><span class="line">   c = a.add(b);</span><br><span class="line">   c = a.subtract(b);</span><br><span class="line">   c = a.multiply(b);</span><br><span class="line">   c = a.divide(b);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//判等和比较大小</span></span><br><span class="line">   <span class="keyword">boolean</span> d = a.equals(b);</span><br><span class="line">   <span class="keyword">int</span> e = a.compareTo(b);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//常用的操作</span></span><br><span class="line">   c = a.mod(b);</span><br><span class="line">   c = a.gcd(b);</span><br><span class="line">   c = a.max(b);</span><br><span class="line">   c = a.min(b);</span><br><span class="line">   c = a.pow(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//计算长度</span></span><br><span class="line">   <span class="keyword">int</span> len = a.toString().length();</span><br></pre></td></tr></table></figure><h4 id="2-java-math-BigDecimal"><a href="#2-java-math-BigDecimal" class="headerlink" title="2.java.math.BigDecimal"></a>2.java.math.BigDecimal</h4><p>常用操作：<br>• BigDecimal add(BigDecimal other)<br>• BigDecimal subtract(BigDecimal other)<br>• BigDecimal multipiy(BigDecimal other)<br>• BigDecimal divide(BigDecimal other RoundingMode mode)<br>返回这个大实数与另一个大实数 other 的和、 差、 积、 商。<strong>要想计算商， 必须给出舍入方式 （rounding mode)</strong>。RoundingMode.HALF_UP 是在学校中学习的四舍五入方式 (BP, 数值 0 到 4 舍去， 数值 5 到 9 进位） 。它适用于常规的计算。有关其他的舍入方 式请参看 API文档。<br>• int compareTo(BigDecimal other)<br> 如果这个大实数与另一个大实数相等， 返回 0 ; 如果这个大实数小于另一个大实数， 返回负数； 否则，返回正数。<br> • static BigDecimal valueOf(long x)<br>  • static BigDecimal valueOf（double x）<br> • static BigDecimal valueOf(long x,int scale)<br> 返回值为 x 或 x / 10^scale^ 的一个大实数。</p><p>　　具体的代码实现与例1.1类似，不赘述。但是在做除法的需要注意一下舍入方式。</p><h4 id="3-补充"><a href="#3-补充" class="headerlink" title="3.补充"></a>3.补充</h4><p>　　关于舍入方式可以参考一下：<a href="https://blog.csdn.net/alanzyy/article/details/8465098" target="_blank" rel="noopener">DecimalFormat对数值格式化的舍入问题——RoundingMode</a><br>　　另外，关于本博文，可以参考一下：<a href="https://www.baidu.com/link?url=C2L7-qJzHXHCov4Gmjy3WErIEriL4U6fBf4-TfiYNG_fk-NtBsGMET73YySrb80hKs_zm8dRlv_2tN_wJ0ZW_paMoIbsvGHWcNfkr0IwLn_&wd=&eqid=8724d1520056db05000000035e34d4d4" target="_blank" rel="noopener">java大数详解</a> 和 <a href="https://www.baidu.com/link?url=09YhJWRVoPT9YRVLjSnMP7dkSH294wV3OEi3HBtxsXtlRWB18fYQ5afMNLSt6q9wBxajJjAH9z2VZTEa1Mv7p_&wd=&eqid=8724d1520056db05000000035e34d4d4" target="_blank" rel="noopener">java 大数详细讲解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h4&gt;&lt;p&gt;　　如果基本的整数和浮点数精度不能够满足需求， 那么可以使用java.math 包中的两个很有用的类：Biglnteger 和 BigDecimaL 这两个类可以处理包含&lt;strong&gt;任意长度&lt;/strong&gt;数字序列的数值。 Biglnteger类实现了&lt;strong&gt;任意精度&lt;/strong&gt;的整数运算， BigDecimal 实现了任意精度的浮点数运算。 &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://P-apa.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java中常用的排序方法</title>
    <link href="http://p-apa.github.io/2020/01/31/java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/"/>
    <id>http://p-apa.github.io/2020/01/31/java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/</id>
    <published>2020-01-31T12:16:53.000Z</published>
    <updated>2020-02-02T05:26:50.205Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-调用Arrays-sort-对一维数组排序"><a href="#1-调用Arrays-sort-对一维数组排序" class="headerlink" title="1.调用Arrays.sort()对一维数组排序"></a>1.调用Arrays.sort()对一维数组排序</h5><a id="more"></a> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//升序排列</span></span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        Arrays.sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">        <span class="comment">//降序排列</span></span><br><span class="line">        Integer[] array2 = &#123;<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        Arrays.sort(array2,Collections.reverseOrder());</span><br><span class="line">        System.out.println(Arrays.toString(array2));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        上面的升序排列也可以写成：</span></span><br><span class="line"><span class="comment">        Integer[] array = &#123;6,1,7,8,5,3,2,10,9,4&#125;;</span></span><br><span class="line"><span class="comment">        Arrays.sort(array);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(array));</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://github.com/P-apa/imageRepo/raw/master/blog_2_sort-method-in-java/image_1.PNG" alt=""></p><h5 id="2-通过实现Comparator接口完成对二维数组-复合类型j进行排序"><a href="#2-通过实现Comparator接口完成对二维数组-复合类型j进行排序" class="headerlink" title="2.通过实现Comparator接口完成对二维数组/复合类型j进行排序"></a>2.通过实现Comparator接口完成对二维数组/复合类型j进行排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] array = &#123;&#123;<span class="number">5</span>,<span class="number">0</span>&#125;,&#123;<span class="number">7</span>,<span class="number">0</span>&#125;,&#123;<span class="number">6</span>,<span class="number">0</span>&#125;&#125;;<span class="comment">//定义了array[3][2]大小的二维数组</span></span><br><span class="line">        Arrays.sort(array,<span class="keyword">new</span> MyComparator());<span class="comment">//以一维数组的第一个元素的大小排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row:array)</span><br><span class="line">            System.out.println(Arrays.toString(row));<span class="comment">//输出排序后二维数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a=(<span class="keyword">int</span>[])o1;</span><br><span class="line">        <span class="keyword">int</span>[] b=(<span class="keyword">int</span>[])o2;</span><br><span class="line">        <span class="comment">//升序</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>]&gt;b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>]&lt;b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//降序</span></span><br><span class="line">        <span class="comment">/*if (a[0]&gt;b[0])</span></span><br><span class="line"><span class="comment">            return -1;</span></span><br><span class="line"><span class="comment">        if (a[0]&lt;b[0])</span></span><br><span class="line"><span class="comment">            return 1;</span></span><br><span class="line"><span class="comment">        return 0;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://github.com/P-apa/imageRepo/raw/master/blog_2_sort-method-in-java/image_2.PNG" alt=""></p><h5 id="3-利用Collections-sort-对动态数组排序"><a href="#3-利用Collections-sort-对动态数组排序" class="headerlink" title="3.利用Collections.sort()对动态数组排序"></a>3.利用Collections.sort()对动态数组排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList3 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">            arrayList3.add(<span class="keyword">new</span> Random().nextInt(<span class="number">100</span>));<span class="comment">//随机产生5个100以内的数add到ArrayList3</span></span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"排序前："</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer r:arrayList3)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(r+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Collections.sort(arrayList3, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1&gt;o2)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (o1&lt;o2)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.print(<span class="string">"排序后："</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer r:arrayList3)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(r+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://github.com/P-apa/imageRepo/raw/master/blog_2_sort-method-in-java/image_3.PNG" alt=""></p><p><strong><em>总结一下：</em></strong><br>java中常用的排序方法有Arrays.sort()和Collections.sort()两种：<br><strong>Arrays.sort()</strong> 主要是针对各种数据类型（基本数据类型和引用对象类型）的数组元素排序。需要注意的是：比如int[]，double[]，char[]等基数据类型的数组，Arrays类只是提供了默认的升序排列，没有提供相应的降序排列方法；要对基础类型的数组进行降序排序，需要将这些数组转化为对应的封装类数组，如Integer[]，Double[]，Character[]等，对这些类数组进行排序(逆序需要实现Comparator接口)。<br><strong>Collection.sort()</strong> 主要是针对集合框架中的动态数组，链表，树，哈希表等（ ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap ）进行排序。</p><p>另外，大家可以参考一下：<br><a href="https://www.cnblogs.com/zz22--/p/10705970.html" target="_blank" rel="noopener">https://www.cnblogs.com/zz22–/p/10705970.html</a><br><a href="https://www.cnblogs.com/xudong-bupt/p/3168618.html" target="_blank" rel="noopener">https://www.cnblogs.com/xudong-bupt/p/3168618.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-调用Arrays-sort-对一维数组排序&quot;&gt;&lt;a href=&quot;#1-调用Arrays-sort-对一维数组排序&quot; class=&quot;headerlink&quot; title=&quot;1.调用Arrays.sort()对一维数组排序&quot;&gt;&lt;/a&gt;1.调用Arrays.sort()对一维数组排序&lt;/h5&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
