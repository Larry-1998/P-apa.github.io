<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宗沅のBLOG</title>
  
  <subtitle>一步一步往上爬的瓜牛</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://daofenglee.cn/"/>
  <updated>2020-10-14T15:48:02.993Z</updated>
  <id>http://daofenglee.cn/</id>
  
  <author>
    <name>宗沅</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>蓝桥杯赛前复习</title>
    <link href="http://daofenglee.cn/2020/10/13/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%8D%E4%B9%A0/"/>
    <id>http://daofenglee.cn/2020/10/13/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-10-13T14:52:57.541Z</published>
    <updated>2020-10-14T15:48:02.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="蓝桥杯赛前复习"><a href="#蓝桥杯赛前复习" class="headerlink" title="蓝桥杯赛前复习"></a>蓝桥杯赛前复习</h1><p><strong>1、0-1背包</strong></p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/P-apa/imageRepo@3.0/blog_img/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%8D%E4%B9%A0/0-1%E8%83%8C%E5%8C%85.png" alt="0-1背包"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n,W;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] w,v;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] dp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n=in.nextInt();W=in.nextInt();</span><br><span class="line">        w=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];v=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][W+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            w[i]=in.nextInt();</span><br><span class="line">            v[i]=in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        Knap();</span><br><span class="line">        System.out.println(dp[n][W]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Knap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,r;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (r=<span class="number">0</span>;r&lt;=W;r++)</span><br><span class="line">            dp[<span class="number">0</span>][r]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//按行填写</span></span><br><span class="line">            <span class="keyword">for</span> (r=<span class="number">1</span>;r&lt;=W;r++)&#123;<span class="comment">//dp[i,r]表示在前i个物品中挑选总重量不超过r的物品，即i表示物品个数，r表示此时背包的容量</span></span><br><span class="line">                <span class="keyword">if</span> (r&lt;w[i])</span><br><span class="line">                    dp[i][r]=dp[i-<span class="number">1</span>][r];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][r]=Math.max(dp[i-<span class="number">1</span>][r],dp[i-<span class="number">1</span>][r-w[i]]+v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、完全背包</strong></p><p>问题描述：</p><p>已知:有一个容量为V的背包和N件物品，第i件物品的重量是weight[i]，收益是cost[i]。</p><p>条件:每种物品都有无限件，能放多少就放多少。</p><p>问题:在不超过背包容量的情况下，最多能获得多少价值或收益</p><p>举例：物品个数N = 3，背包容量为V = 5，则背包可以装下的最大价值为40.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*方法1：转换为0-1背包问题</span></span><br><span class="line"><span class="comment">因为背包的容量有限，即使是只装一件物品，那么装的件数k最大为V(背包容量)/w(该物品的重量)。这里就将无限的转换为有限的了。同时，将同一件物品看成不同的物品，当然原来的物品件数也会相应增加。这就转换成了0-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//代码略</span></span><br><span class="line"><span class="comment">/*方法2：迭代方程： f[v] = max(f[v],f[v - weight[i]] + Value[i])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] f=<span class="keyword">new</span> <span class="keyword">int</span>[V+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Completeknapsack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=weight[i];v&lt;=V;v++)&#123;</span><br><span class="line">        f[v]=Math.max(f[v],f[v-weight[i]]+value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> f[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、多重背包</strong></p><p><strong>4、计算日期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.计算星期数</span></span><br><span class="line"><span class="comment">//吉姆拉尔森公式</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">weekdays</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> m,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m==<span class="number">1</span>||m==<span class="number">2</span>)&#123;</span><br><span class="line">            m+=<span class="number">12</span>;</span><br><span class="line">            y--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> w=(d+<span class="number">2</span>*m+<span class="number">3</span>*(m+<span class="number">1</span>)/<span class="number">5</span>+y+y/<span class="number">4</span>-y/<span class="number">100</span>+y/<span class="number">400</span>)%<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">return</span> ++w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> y=in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m=in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> d=in.nextInt();</span><br><span class="line">        System.out.println( weekdays(y,m,d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">利用基准日期：(w+totaldays-1)%7+1，计算结果取值为(1~7)。w是基准日期的星期数(取值为1~7)，totaldays是自基准日期到给定日期的天数。给定日期在基准日期之前：((w-totaldays-1)%7+7)%7+1。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>5、含有重复数字的全排列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求数组必须有序，所以在调用函数前必须排序</span></span><br><span class="line"><span class="comment">//小于等于10（值不相同）耗时小于1s，11时就大于1秒</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//全排列</span></span><br><span class="line">        n=<span class="number">4</span>;</span><br><span class="line">        numbers= <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>, <span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        ans=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        vis=<span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//含重复数字的全排列</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] numbers,ans;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] vis;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;n)&#123;</span><br><span class="line">            display();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> last=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="keyword">false</span>&amp;&amp;numbers[i]!=last)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i]=<span class="keyword">true</span>;</span><br><span class="line">                ans[k]=numbers[i];</span><br><span class="line">                last=numbers[i];</span><br><span class="line">                dfs(k+<span class="number">1</span>);</span><br><span class="line">                vis[i]=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            System.out.print(ans[i]);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、将数字转换为字符串的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//method1:</span></span><br><span class="line">String str1=<span class="string">""</span>+a;</span><br><span class="line">String str2=String.ValueOf(a);</span><br><span class="line">String str3=(String)a;</span><br></pre></td></tr></table></figure><p><strong>7、BigInteger、BigDecimal</strong></p><p><strong>8、拓展欧几里得算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x, y;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span>; </span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a%b);</span><br><span class="line">    <span class="keyword">int</span> t = y;</span><br><span class="line">    y = x - a/b*y;</span><br><span class="line">    x = t; </span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>9、Dijkstra算法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/P-apa/imageRepo@3.0/blog_img/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%8D%E4%B9%A0/Dijkstra.png" alt="Dijkstra"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dijkstra算法, Description : 贪心, O(N^2), 不能有负权</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dis,S;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n,x;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] w;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Arrays.fill(dis, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        dis[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">// 循环n次， 每次找出一个离起点最近的点。</span></span><br><span class="line">            <span class="keyword">int</span> t = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(S[j] == <span class="number">0</span> &amp;&amp; (t == -<span class="number">1</span> || dis[t] &gt; dis[j]))&#123; <span class="comment">// 找到一个距离最短的加入S集合。</span></span><br><span class="line">                    t = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            S[t] = <span class="number">1</span>;  <span class="comment">// 然后通过这个点来缩短原点到达其他点的距离。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                dis[j] = Math.min(dis[j], dis[t] + w[t][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dis[n] != <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> dis[n];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        n=<span class="number">6</span>;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        dis=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        S=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        w=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=n; i++)</span><br><span class="line">            Arrays.fill(w[i], <span class="number">0x3f3f3f3f</span>);</span><br><span class="line"></span><br><span class="line">        w[<span class="number">1</span>][<span class="number">3</span>]=<span class="number">10</span>;</span><br><span class="line">        w[<span class="number">1</span>][<span class="number">5</span>]=<span class="number">30</span>;</span><br><span class="line">        w[<span class="number">1</span>][<span class="number">6</span>]=<span class="number">100</span>;</span><br><span class="line">        w[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">5</span>;</span><br><span class="line">        w[<span class="number">3</span>][<span class="number">4</span>]=<span class="number">50</span>;</span><br><span class="line">        w[<span class="number">4</span>][<span class="number">6</span>]=<span class="number">10</span>;</span><br><span class="line">        w[<span class="number">5</span>][<span class="number">6</span>]=<span class="number">60</span>;</span><br><span class="line">        w[<span class="number">5</span>][<span class="number">4</span>]=<span class="number">20</span>;</span><br><span class="line">        Dijkstra();</span><br><span class="line">        System.out.println(dis[<span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>10、Prime算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Arrays.fill(dis, <span class="number">0x3f3f3f3f</span>); <span class="comment">//设所有边距离边集的的距离为正无穷，也就是设所有边的状态为不可查找</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">// 存储最小生成树的总边权</span></span><br><span class="line">        dis[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 设1号点距离边集的距离为0；dis[j]表示节点j到生成树节点的距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;<span class="comment">// 循环n次</span></span><br><span class="line">            <span class="keyword">int</span> t = -<span class="number">1</span>;    </span><br><span class="line">            <span class="keyword">int</span> minv = INF; <span class="comment">//存储最短边</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;<span class="comment">//每循环n次，从未加入最小生成树的节点中选出离最小生成树点集最近的节点</span></span><br><span class="line">                <span class="keyword">if</span>(st[j] == <span class="number">0</span> &amp;&amp; minv &gt; dis[j])&#123;</span><br><span class="line">                    t = j;</span><br><span class="line">                    minv = dis[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(minv == INF) <span class="keyword">return</span> INF;<span class="comment">// 最短边是无穷大，说明该图不连通</span></span><br><span class="line">            res += dis[t];</span><br><span class="line">            st[t] = <span class="number">1</span>;</span><br><span class="line">           <span class="comment">//将t的邻接边的状态更新为待查找</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="comment">// 或者说是缩短t的邻接点到达边集的距离    </span></span><br><span class="line">                dis[j] = Math.min(dis[j], g[t][j]); </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>11、快速幂</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="comment">//求 a^b</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>; <span class="comment">// res保存结果</span></span><br><span class="line"><span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123; <span class="comment">//如果k的二进制数的最后一位是 1。 比如1011 &amp; 1 = 1</span></span><br><span class="line">res = (res * a) % mod;<span class="comment">//取模， 防止结果溢出。</span></span><br><span class="line">&#125;</span><br><span class="line">a = a * a % mod;<span class="comment">//得到 a^1, a^2, a^4, a^8, .....</span></span><br><span class="line">b = b &gt;&gt; <span class="number">1</span>; <span class="comment">//将b右移一位，去掉最低位。为了开始判断下一位。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>12、矩阵乘法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">matix_mul</span><span class="params">(<span class="keyword">long</span>[][] a, <span class="keyword">long</span>[][] b, <span class="keyword">long</span>[][] c)</span></span>&#123; <span class="comment">// c = a * b</span></span><br><span class="line"><span class="keyword">long</span>[][] t = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;; <span class="comment">// 中间数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">t[i][j] = (t[i][j] + (a[i][k]*b[k][j]) % mod)%mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) c[i] = Arrays.copyOf(t[i], <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;蓝桥杯赛前复习&quot;&gt;&lt;a href=&quot;#蓝桥杯赛前复习&quot; class=&quot;headerlink&quot; title=&quot;蓝桥杯赛前复习&quot;&gt;&lt;/a&gt;蓝桥杯赛前复习&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、0-1背包&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://daofenglee.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://daofenglee.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="蓝桥杯" scheme="http://daofenglee.cn/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>模拟进程并发执行</title>
    <link href="http://daofenglee.cn/2020/10/13/%E6%A8%A1%E6%8B%9F%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C/"/>
    <id>http://daofenglee.cn/2020/10/13/%E6%A8%A1%E6%8B%9F%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C/</id>
    <published>2020-10-13T05:37:43.812Z</published>
    <updated>2020-10-13T05:39:52.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模拟进程并发执行"><a href="#模拟进程并发执行" class="headerlink" title="模拟进程并发执行"></a>模拟进程并发执行</h1><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exp1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimulateConcurrence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        theFrame test=<span class="keyword">new</span> theFrame();</span><br><span class="line">        test.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<span class="comment">//框架关闭时退出程序</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            test.t1.run();</span><br><span class="line">            test.t2.run();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//窗体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">theFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  thePanel1 thePanel1=<span class="keyword">new</span> thePanel1(<span class="number">1</span>,<span class="string">"E:\\Users\\gzy\\Desktop\\照片\\OS\\1.jpg"</span>);</span><br><span class="line">    <span class="keyword">public</span>  thePanel1 thePanel2=<span class="keyword">new</span> thePanel1(<span class="number">2</span>,<span class="string">"E:\\Users\\gzy\\Desktop\\照片\\OS\\2.jpg"</span>);</span><br><span class="line">    <span class="keyword">private</span> Container con=getContentPane();<span class="comment">//创建一个容器</span></span><br><span class="line">    Thread t1=<span class="keyword">new</span> Thread(thePanel1);</span><br><span class="line">    Thread t2=<span class="keyword">new</span> Thread(thePanel2);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">theFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"模拟进程的并发执行"</span>);</span><br><span class="line">        setSize(<span class="number">800</span>,<span class="number">800</span>);</span><br><span class="line">        setLocationRelativeTo(<span class="keyword">null</span>);<span class="comment">//把窗口位置设置到屏幕中心</span></span><br><span class="line">        GridLayout gridLayout=<span class="keyword">new</span> GridLayout(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        con.setLayout(gridLayout);</span><br><span class="line">        con.add(thePanel1);</span><br><span class="line">        con.add(thePanel2);</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thePanel1</span> <span class="keyword">extends</span> <span class="title">JPanel</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JLabel jLabel=<span class="keyword">new</span> JLabel();<span class="comment">//添加标签</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">500</span>;<span class="comment">//用来控制其窗体的y坐标</span></span><br><span class="line"></span><br><span class="line">    JButton stop,start;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    String url;<span class="comment">//绝对路径</span></span><br><span class="line">    Icon icon;</span><br><span class="line"></span><br><span class="line">    thePanel1(<span class="keyword">int</span> i,String url)&#123;</span><br><span class="line"></span><br><span class="line">        setLayout(<span class="keyword">null</span>);</span><br><span class="line">        setBorder(BorderFactory.createTitledBorder(<span class="string">"模拟进程"</span>+i));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.url=url;</span><br><span class="line">        <span class="keyword">this</span>.icon=<span class="keyword">new</span> ImageIcon(url);</span><br><span class="line"></span><br><span class="line">        jLabel.setIcon(icon);</span><br><span class="line">        jLabel.setBounds(<span class="number">100</span>,<span class="number">50</span>,<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">        jLabel.setHorizontalAlignment(SwingConstants.LEFT);<span class="comment">//让其在最左边显示</span></span><br><span class="line">        jLabel.setOpaque(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        stop=<span class="keyword">new</span> JButton(<span class="string">"暂停"</span>);</span><br><span class="line">        start=<span class="keyword">new</span> JButton(<span class="string">"开始"</span>);</span><br><span class="line">        stop.setBounds(<span class="number">100</span>,<span class="number">700</span>,<span class="number">70</span>,<span class="number">35</span>);</span><br><span class="line">        start.setBounds(<span class="number">300</span>,<span class="number">700</span>,<span class="number">70</span>,<span class="number">35</span>);</span><br><span class="line">        add(stop);</span><br><span class="line">        add(start);</span><br><span class="line">        add(jLabel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent actionEvent)</span> </span>&#123;</span><br><span class="line">                flag=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        start.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent actionEvent)</span> </span>&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">0</span> &amp;&amp; flag==<span class="keyword">true</span>)&#123;</span><br><span class="line">            jLabel.setBounds(<span class="number">100</span>, count, <span class="number">200</span>, <span class="number">130</span>);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.currentThread().sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            count-=<span class="number">10</span>;<span class="comment">//每次循环自减的值</span></span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;<span class="comment">//当到达最上边时，设置count值在最下边</span></span><br><span class="line">                count=<span class="number">500</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模拟进程并发执行&quot;&gt;&lt;a href=&quot;#模拟进程并发执行&quot; class=&quot;headerlink&quot; title=&quot;模拟进程并发执行&quot;&gt;&lt;/a&gt;模拟进程并发执行&lt;/h1&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="http://daofenglee.cn/2020/09/27/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://daofenglee.cn/2020/09/27/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-09-27T14:01:42.588Z</published>
    <updated>2020-09-28T06:37:50.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><ol><li>程序(<code>program</code>):是为完成某一任务、用某种编程语言编写的指令集合。是一段<strong>静态</strong>代码。</li><li>进程(<code>process</code>):是程序的一次执行过程，或是一个正在运行的程序。是一个<strong>动态</strong>过程。</li><li>线程(<code>thread</code>):是一个程序内部的<strong>一条执行路径</strong>。</li><li>并行:多个CPU同时执行多个任务。</li><li>并发:一个CPU同时执行多个任务(采用时间片的方式)。<a id="more"></a><h3 id="二、线程的创建和使用"><a href="#二、线程的创建和使用" class="headerlink" title="二、线程的创建和使用"></a>二、线程的创建和使用</h3></li></ol><p><strong>(一)、多线程的创建方式一：继承于Thread类</strong></p><p>步骤：</p><ol><li>创建一个继承于Thread类的子类；</li><li>重写Thread类的子类的run()；</li><li>创建Thread类的子类的对象；</li><li>通过此对象调用start()。</li></ol><p><strong>注意：</strong></p><ol><li>不能直接通过调用run()启动线程；</li><li>当前线程正在执行的时候不能再去调用它的start()。</li></ol><p>创建线程实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gzy.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                System.out.println(getName()+<span class="string">": "</span>+i);<span class="comment">//输出偶数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread1 a=<span class="keyword">new</span> Thread1(<span class="string">"线程1"</span>);</span><br><span class="line">        Thread1 b=<span class="keyword">new</span> Thread1(<span class="string">"线程2"</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上述方式实现的线程存在安全问题！下面先给一个例子，原因后续章节会说明。</p><p>执行下面的代码输出结果有两个’100’，线程安全的情况不会有这种情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gzy.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeProblem</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num=<span class="number">100</span>;<span class="comment">//声明一个静态变量</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">" :"</span>+num--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ThreadSafeProblem a=<span class="keyword">new</span> ThreadSafeProblem();</span><br><span class="line">        ThreadSafeProblem b=<span class="keyword">new</span> ThreadSafeProblem();</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/P-apa/imageRepo@2.0/blog_img/Java%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8.png" alt="线程安全"></p><p><strong>(二)、Thread类中常用的方法</strong></p><ol><li>start()：启动当前线程；调用当前线程的run()</li><li>run()：将创建的线程要执行的操作声明在此方法中</li><li>currentThead() ：静态方法，返回当前代码的线程</li><li>getName()：获取当前线程的名字</li><li>setName：设置当前线程的名字</li><li>yield() ：释放当前线程的CPU执行权</li><li>join()：在线程a中调用线程b的join()，此时线程a进入阻塞状态，直到线程b完全执行完成以后，线程a才结束阻塞状态</li><li><del>stop()</del>：强制结束当前线程</li><li>sleep(long millitime) ：静态方法，让当前进程休眠指定的millitime毫秒。在指定的millitime毫秒内，当前进程处于阻状态</li><li>isAlive()：判断当前进程是否结束</li></ol><p><strong>(三)、线程的调度</strong></p><p>Java的调度方法:时间片(队列)、抢占式(高优先级的线程抢占CPU)</p><p>Java中线程的三个优先级：</p><table><thead><tr><th align="left">Modifier and Type</th><th align="left">Field and Description</th><th align="center">VALUE</th></tr></thead><tbody><tr><td align="left"><code>static int</code></td><td align="left"><code>MAX_PRIORITY</code></td><td align="center">10</td></tr><tr><td align="left"><code>static int</code></td><td align="left"><code>MIN_PRIORITY</code></td><td align="center">5</td></tr><tr><td align="left"><code>static int</code></td><td align="left"><code>NORM_PRIORITY</code></td><td align="center">1</td></tr></tbody></table><p>获取线程的优先级：<code>int</code>  <code>getPriority()</code></p><p>设置线程的优先级：<code>void``setPriority(int newPriority)</code></p><p>线程优先级实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gzy.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Priority</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                System.out.println(getName()+<span class="string">",优先级： "</span>+getPriority()+<span class="string">" ,"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Priority a=<span class="keyword">new</span> Priority();</span><br><span class="line">        Priority b=<span class="keyword">new</span> Priority();</span><br><span class="line">        <span class="comment">//输出三个线程的优先级</span></span><br><span class="line"><span class="comment">/*        System.out.println(Thread.currentThread().getName()+","+"priority:"+Thread.currentThread().getPriority());</span></span><br><span class="line"><span class="comment">        System.out.println(a.getName()+","+"priority:"+a.getPriority());</span></span><br><span class="line"><span class="comment">        System.out.println(b.getName()+","+"priority:"+b.getPriority());*/</span></span><br><span class="line">        a.setPriority(a.MAX_PRIORITY);</span><br><span class="line">        b.setPriority(b.MIN_PRIORITY);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(四)、创建多线程的方式二：实现Runnable接口</strong></p><p>步骤：</p><ol><li>创建实现了Runnable接口的类</li><li>实现Runnable中的抽象方法：run()</li><li>创建实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li><li>通过Thread类的对象调用start()</li></ol><p>用<code>Runnable</code>接口创建线程实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gzy.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplementRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" :"</span>+num--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ImplementRunnable runnable=<span class="keyword">new</span> ImplementRunnable();</span><br><span class="line">        Thread a=<span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread b=<span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：同样，上述方式实现的线程存在安全问题！执行结果如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/P-apa/imageRepo@2.0/blog_img/Java%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A82.png" alt="线程安全2"></p><p><strong>(五)、比较两种创建线程的两种方式</strong></p><p>开发中：优先选择实现Runnable接口的方式</p><p>原因：</p><ol><li>实现的方式没有类的单继承性的局限性</li><li>实现的方式更适合来处理多个线程有共享数据的情况</li></ol><p>联系：Thread类实现了Runnable接口；两种方式都需要重写run()，将线程要执行的逻辑声明在run()中</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h2&gt;&lt;h3 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、基本概念&quot;&gt;&lt;/a&gt;一、基本概念&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;程序(&lt;code&gt;program&lt;/code&gt;):是为完成某一任务、用某种编程语言编写的指令集合。是一段&lt;strong&gt;静态&lt;/strong&gt;代码。&lt;/li&gt;
&lt;li&gt;进程(&lt;code&gt;process&lt;/code&gt;):是程序的一次执行过程，或是一个正在运行的程序。是一个&lt;strong&gt;动态&lt;/strong&gt;过程。&lt;/li&gt;
&lt;li&gt;线程(&lt;code&gt;thread&lt;/code&gt;):是一个程序内部的&lt;strong&gt;一条执行路径&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;并行:多个CPU同时执行多个任务。&lt;/li&gt;
&lt;li&gt;并发:一个CPU同时执行多个任务(采用时间片的方式)。
    
    </summary>
    
    
      <category term="java" scheme="http://daofenglee.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://daofenglee.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java异常处理机制</title>
    <link href="http://daofenglee.cn/2020/09/24/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://daofenglee.cn/2020/09/24/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</id>
    <published>2020-09-24T11:45:40.099Z</published>
    <updated>2020-09-27T14:04:03.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java异常处理机制"><a href="#Java异常处理机制" class="headerlink" title="Java异常处理机制"></a>Java异常处理机制</h1><h3 id="一、异常的概述"><a href="#一、异常的概述" class="headerlink" title="一、异常的概述"></a>一、异常的概述</h3><p>Java程序在执行过程中所发生的异常事件可分为两类：</p><ol><li><p><code>Error</code>：Java虚拟机无法解决的严重问题。如栈溢出，堆溢出(OutOfMemory)。需要改代码。</p></li><li><p><code>Exception</code>: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。比如：空指针访问、试图读取不存在的文件、网络连接中断、数组角标越界等。</p></li></ol><p>而我们说的异常通常指的是可以使用针对性的代码进行处理的异常，即<code>Exception</code>类异常。后面的内容也是对<code>Exception</code>类异常的讲解。</p><a id="more"></a><h3 id="二、Exception异常分类"><a href="#二、Exception异常分类" class="headerlink" title="二、Exception异常分类"></a>二、Exception异常分类</h3><p><strong>运行时异常</strong>：指编译器不强制处理的异常。一般是指编程的时逻辑错误。对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。</p><p><strong>编译时异常</strong>：编译器要求必须处理的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常。</p><h3 id="三、异常的体系结构及常见异常"><a href="#三、异常的体系结构及常见异常" class="headerlink" title="三、异常的体系结构及常见异常"></a>三、异常的体系结构及常见异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Throwable</span><br><span class="line">    |-----java.lang.Error:一般不编写针对性的代码进行处理。</span><br><span class="line">    |-----java.lang.Exception:可以进行异常的处理。</span><br><span class="line">        |-----编译时异常（checked）</span><br><span class="line">            |-----IOException</span><br><span class="line">                |-----FileNotFoundException</span><br><span class="line">                |-----EOFException</span><br><span class="line">            |-----ClassNotFoundException</span><br><span class="line">        |-----运行时异常（unchecked）</span><br><span class="line">            |-----NullPointerException</span><br><span class="line">            |-----ClassCastException（类型转换异常）</span><br><span class="line">            |-----ArithmeticException</span><br><span class="line">            |-----NumberFormatException</span><br><span class="line">            |-----InputMismatchException</span><br></pre></td></tr></table></figure><h3 id="四、异常处理机制"><a href="#四、异常处理机制" class="headerlink" title="四、异常处理机制"></a>四、异常处理机制</h3><p><strong>(一)、异常处理机制：“抓抛”模型</strong></p><p>过程一：“抛”<br>程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出。一旦抛出对象以后，此后的代码(try块内的)就不再执行。其中异常对象的生成有两种方式：(1)系统自动生成，(2)手动生成异常对象并抛出(<code>throw</code>，注意这里不是<code>throws</code>)</p><p>过程二：”抓”<br>可以理解为异常的处理方式：(2)try-catch-finally，(2)throws</p><p><strong>(二)、异常的第一种处理方式：try-catch-finally</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     <span class="comment">//可能出现异常的代码 </span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line">     <span class="comment">//处理异常的方式1</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line">     <span class="comment">//处理异常的方式2</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line">     <span class="comment">//处理异常的方式2</span></span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">     <span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li>finally是可选的；</li><li>使用try将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型去catch中进行匹配；</li><li>一旦try中的异常对象去配到某一个catch时，就进入catch中进行异常处理。一旦处理完成就跳出当前的try-catch结构（没有写finally的情况），继续执行其后的代码；</li><li>catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓；如果满足子父类关系，则要求子类一定声明在父类的上面，否则报错；</li><li>常用的异常处理方式：(1). <code>String getMessage()</code>,(2)<code>printStackTrace()</code></li><li>在try结构中声明的变量，出了try结构后就不能再被调用；</li><li>使用try-catch-finally处理编译时异常，使得程序在编译时不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时的异常延迟到运行时出现；</li><li>在开发中，由于运行时异常比较常见，所以通常我们就不针对运行时异常编写try-catch-finally。针对编译时异常，一定要考虑异常的处理。</li></ol><p>(三)、异常处理的第二种方式：throws+异常类型</p><ol><li><p>“throws+异常类型”写在方法声明处。指出该方法在执行时可能会抛出的异常类型。一旦当方法体执行时出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws语句后的异常类型时，就会被抛出。<strong>异常代码后续的代码，就不再执行！</strong></p></li><li><p>try-catch-finally的方式真正地将异常给处理掉了；而throws的方式只是将异常抛给了方法的调用者，并没有真正将异常处理掉。</p></li><li><p>开发中如何选择使用try-catch-finally 还是使用throws？</p></li></ol><ul><li>如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。<ul><li>执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。</li></ul></li></ul><h3 id="五、异常方法重写"><a href="#五、异常方法重写" class="headerlink" title="五、异常方法重写"></a>五、异常方法重写</h3><p>方法重写的规则之一：子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">OverrideTest test = <span class="keyword">new</span> OverrideTest();</span><br><span class="line">test.display(<span class="keyword">new</span> SubClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(SuperClass s)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">s.method();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span><span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、手动抛出异常：throw"><a href="#六、手动抛出异常：throw" class="headerlink" title="六、手动抛出异常：throw"></a>六、手动抛出异常：throw</h3><p>手动抛出异常是相对于系统自动抛出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">s.regist(-<span class="number">1001</span>);</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regist</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//手动抛出异常对象</span></span><br><span class="line">            <span class="comment">//  throw new RuntimeException("您输入的数据非法！");</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"您输入的数据非法！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Student [id="</span> + id + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、自定义异常类"><a href="#七、自定义异常类" class="headerlink" title="七、自定义异常类"></a>七、自定义异常类</h3><p>步骤：</p><ol><li>继承于现有的异常结构：<code>RuntimeException</code> 、<code>Exception</code></li><li>提供全局常量：serialVersionUID</li><li>提供重载的构造器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7034897193246939L</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h3><p>这里学的异常处理并不是解决异常的根本方法，而是将可能出现的异常以一种”友好”的方式展现出来。比如用户点击了一个按钮，此时代码出现了异常，如果不针对这个异常进行处理的话可能展示出来的就是一段乱码或程序直接闪退；而进行异常处理就可用对话框的形式向用户发出错误提示信息，也可以将这个错误信息发送到后台，供开发人员进行修改。<br>而对于异常根本的解决方法就是修改代码，解决这个异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java异常处理机制&quot;&gt;&lt;a href=&quot;#Java异常处理机制&quot; class=&quot;headerlink&quot; title=&quot;Java异常处理机制&quot;&gt;&lt;/a&gt;Java异常处理机制&lt;/h1&gt;&lt;h3 id=&quot;一、异常的概述&quot;&gt;&lt;a href=&quot;#一、异常的概述&quot; class=&quot;headerlink&quot; title=&quot;一、异常的概述&quot;&gt;&lt;/a&gt;一、异常的概述&lt;/h3&gt;&lt;p&gt;Java程序在执行过程中所发生的异常事件可分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Error&lt;/code&gt;：Java虚拟机无法解决的严重问题。如栈溢出，堆溢出(OutOfMemory)。需要改代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Exception&lt;/code&gt;: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。比如：空指针访问、试图读取不存在的文件、网络连接中断、数组角标越界等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而我们说的异常通常指的是可以使用针对性的代码进行处理的异常，即&lt;code&gt;Exception&lt;/code&gt;类异常。后面的内容也是对&lt;code&gt;Exception&lt;/code&gt;类异常的讲解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://daofenglee.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://daofenglee.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>DFS算法的学习</title>
    <link href="http://daofenglee.cn/2020/09/17/DFS%E7%AE%97%E6%B3%95/"/>
    <id>http://daofenglee.cn/2020/09/17/DFS%E7%AE%97%E6%B3%95/</id>
    <published>2020-09-16T16:37:59.668Z</published>
    <updated>2020-09-24T11:44:09.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DFS算法的学习"><a href="#DFS算法的学习" class="headerlink" title="DFS算法的学习"></a>DFS算法的学习</h1><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a><strong>简述</strong></h3><p>首先，DFS (Depth First Search) 是一种在程序设计竞赛中常用的搜索算法。那么，什么是搜索？搜索可以是在众多数据中找到符合要求的一组数据；也可以是寻找一条从某一起点到目标终点的最佳路径。在这过程中可能会不断作出尝试性的选择来达到访问全局，最终得出结果。</p><a id="more"></a><h3 id="DFS算法思想"><a href="#DFS算法思想" class="headerlink" title="DFS算法思想"></a><strong>DFS算法思想</strong></h3><p>这有类问题在求解时需要一定的步骤。通常求解这些问题采取的策略是:从起始位置(或起始状态)出发，试探性的选择一个可行的步骤到达下一个状态， 而后又从这个状态出发选择一个可 行的步骤达到下一个状态 ……每到达 一个状态如果发现没有可行的步骤则回退到上一步，再试探其他可行的步骤;如果回退到上一步依然没有其他可行的步骤，则继续回退到再上一步;如此反复直到目标位置(或目标状态)，或者所有状态都访问完后还没有找到目标状态，则说明无解。</p><p>在图论中，深度优先遍历主要思路是从图中⼀个未访问的顶点 V 开始，沿着⼀条路⼀直⾛到底，然后从这条路尽头的节点回退到上⼀个节点，再从另⼀条路开始⾛到底……不断递归重复此过程，直到所有的顶点都遍历完成，它的特点是不撞南墙不回头，先⾛完⼀条路，再换⼀条路继续⾛。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a><strong>关键字</strong></h3><p>尝试性选择；回退；递归；当前状态；下一状态</p><h3 id="例题讲解"><a href="#例题讲解" class="headerlink" title="例题讲解"></a><strong>例题讲解</strong></h3><p>接下来通过三道题来理解DFS算法，三道题分别对应于三中不同的场景（矩阵、一位数组和二叉树）。</p><p><strong><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827365609" target="_blank" rel="noopener">1.骨头的诱惑</a></strong></p><p>题目来源：ZOJ2110</p><p>题目描述：<br>    一只小狗在一个古老的迷宫里找到一根骨头，当它叼起骨头时，迷宫开始颤抖，它感觉到地面开始下沉。它才明白骨头是一个陷阱，它拼命地试着逃出迷宫。<br>    迷宫是一个N×M 大小的长方形，迷宫有一个门。刚开始门是关着的，并且这个门会在第T 秒钟开启，门只会开启很短的时间（少于一秒），因此小狗必须恰好在第T 秒达到门的位置。每秒钟，它可以向上、下、左或右移动一步到相邻的方格中。但一旦它移动到相邻的方格，这个方格开始下沉，而且会在下一秒消失。所以，它不能在一个方格中停留超过一秒，也不能回到经过的方格。小狗能成功逃离吗？请你帮助他。<br>输入描述：<br>    输入文件包括多个测试数据。每个测试数据的第一行为三个整数：N,M,T，(1&lt;N, M&lt;7；0&lt;T&lt;50)，分别代表迷宫的长和宽，以及迷宫的门会在第T 秒时刻开启。接下来N 行信息给出了迷宫的格局，每行有M 个字符，这些字符可能为如下值之一：<br>    X: 墙壁，小狗不能进入 S: 小狗所处的位置<br>    D: 迷宫的门 . : 空的方格<br>    输入数据以三个0 表示输入数据结束。<br>输出描述：<br>    对每个测试数据，如果小狗能成功逃离，则输出”YES”，否则输出”NO”。</p><p>样例输入：<br>    3 4 5<br>    S . . .<br>    . X . X<br>    . . . D<br>    4 4 8<br>    . X . X<br>    . . S .<br>    . . . .<br>    D X . X<br>    4 4 5<br>    S . X .<br>    . . X .<br>    . . X D<br>    . . . .<br>    0 0 0</p><p>样例输出：</p><p>YES<br>YES<br>NO</p><p><strong>题目解析</strong><br>                略<br><strong>核心代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m,n,T,X,Y;<span class="comment">//m,n是矩阵的大小;T是第t秒到达;X,Y是终点坐标</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> matrix[m][n];<span class="comment">//迷宫矩阵</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> falg=<span class="keyword">false</span>;<span class="comment">//flag为true则成功逃离，false则没有</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[][] V=&#123;-<span class="number">1</span>,<span class="number">0</span>;<span class="number">0</span>,-<span class="number">1</span>;<span class="number">1</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">1</span>&#125;;<span class="comment">//用来表示上左下右四个方向</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="comment">//下面两个if语句是递归的结束条件，即遇到边界、找到答案</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=m||y&lt;<span class="number">0</span>||y&gt;=n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==X&amp;&amp;y==Y&amp;&amp;t==T)&#123;</span><br><span class="line">        flag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下是按上、左、下、右的顺序进行访问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[x+V[i][<span class="number">0</span>]][y+V[i][<span class="number">1</span>]]==<span class="string">'X'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        matrix[x][y]=<span class="string">'X'</span>;<span class="comment">//将空白处变为墙壁</span></span><br><span class="line">        DFS(x+V[i][<span class="number">0</span>],y+V[i][<span class="number">1</span>],t+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        matrix[x][y]=<span class="string">'.'</span>;<span class="comment">//回退</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a href="http://poj.org/problem?id=1011" target="_blank" rel="noopener">2.小木棍</a></strong></p><p>Description</p><p>乔治拿来一组等长的木棒，将它们随机地砍断，使得每一节木棍的长度都不超过50个长度单位。然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。请你设计一个程序，帮助乔治计算木棒的可能最小长度。每一节木棍的长度都用大于零的整数表示。</p><p>Input</p><p>输入包含多组数据，每组数据包括两行。第一行是一个不超过64的整数，表示砍断之后共有多少节木棍。第二行是截断以后，所得到的各节木棍的长度。在最后一组数据之后，是一个零。</p><p>Output</p><p>为每组数据，分别输出原始木棒的可能最小长度，每组数据占一行。</p><p>Sample Input</p><p>9<br>        5 2 1 5 2 1 5 2 1<br>        4<br>        1 2 3 4<br>        0</p><p>Sample Output</p><p>6<br>        5</p><p>题目要求木棒的最小长度，根据题目可知，木棒的最小长度应该不小于小木棍中最长的那一根的长度。以样例中第二组数据为例，先将小木棍的按有长到短进行排序，即4 3 2 1，假设木棒的长度为4，则组合为4;3,1;2,2!=4，不符合，此时设木棒的长度5，则可以得到组合4,1;3,2，符合题目要求，即最短长度为5。</p><p>样例的第一组数据则要麻烦些，排序后为5 5 5 2 2 21 1 1，</p><p><strong>关键代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pieceNum;    <span class="comment">//切割得到的小段总数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> stickLen;    <span class="comment">//小木棍的长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> stickNum;    <span class="comment">//小木棍的数目</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pieceLen[N];    <span class="comment">//小段的长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> isPieceUsed[N];    <span class="comment">//搜索过程中小段是否被使用</span></span><br><span class="line"><span class="comment">//正在拼接第filledStickNum根小木棍，已经得到的这根小木棍的长度filledLen</span></span><br><span class="line"><span class="comment">//选取小段时的起始编号（不用取编号在startNo之前的小段）</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">search</span><span class="params">( <span class="keyword">int</span> filledStickNum, <span class="keyword">int</span> filledLen, <span class="keyword">int</span> startNo )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( filledStickNum==stickNum )  <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">//存在满足要求的拼接方法</span></span><br><span class="line">    <span class="keyword">int</span> i, p;</span><br><span class="line">    <span class="keyword">for</span>( i=startNo; i&lt;pieceNum; i++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( isPieceUsed[i]==<span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="comment">//如果加入选取的小段之后，这根木棍还没有拼接完成</span></span><br><span class="line">            <span class="keyword">if</span>( (p=filledLen+pieceLen[i])&lt;stickLen ) &#123;</span><br><span class="line">                isPieceUsed[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>( search(filledStickNum,p,i+<span class="number">1</span>) )  <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">//剪枝1</span></span><br><span class="line">                isPieceUsed[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>( startNo==<span class="number">0</span> )  <span class="keyword">break</span>;    <span class="comment">//剪枝2</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( p==stickLen ) &#123;</span><br><span class="line">                isPieceUsed[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>( search(filledStickNum+<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>) )  <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">//剪枝1</span></span><br><span class="line">                isPieceUsed[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;    <span class="comment">//剪枝3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener"><strong>3.二叉树的最大深度</strong></a></p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><p><strong>关键代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> date;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> D,Node L,Node R)</span></span>&#123;</span><br><span class="line">        date=D;</span><br><span class="line">        left=L;</span><br><span class="line">        right=R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS3</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> L=DFS3(root.left)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> R=DFS3(root.right)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(L,R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener"> <strong>4.二叉树的最小深度</strong></a></p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回它的最小深度  2.</p><p><strong>关键代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS4</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+DFS4(root.right);</span><br><span class="line">    <span class="keyword">if</span> (root.right==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+DFS4(root.left);</span><br><span class="line">    <span class="keyword">int</span> L=<span class="number">1</span>+DFS4(root.left);</span><br><span class="line">    <span class="keyword">int</span> R=<span class="number">1</span>+DFS4(root.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+Math.min(L,R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;DFS算法的学习&quot;&gt;&lt;a href=&quot;#DFS算法的学习&quot; class=&quot;headerlink&quot; title=&quot;DFS算法的学习&quot;&gt;&lt;/a&gt;DFS算法的学习&lt;/h1&gt;&lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;首先，DFS (Depth First Search) 是一种在程序设计竞赛中常用的搜索算法。那么，什么是搜索？搜索可以是在众多数据中找到符合要求的一组数据；也可以是寻找一条从某一起点到目标终点的最佳路径。在这过程中可能会不断作出尝试性的选择来达到访问全局，最终得出结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://daofenglee.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://daofenglee.cn/tags/Java/"/>
    
      <category term="DFS" scheme="http://daofenglee.cn/tags/DFS/"/>
    
      <category term="算法" scheme="http://daofenglee.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://daofenglee.cn/2020/07/23/hello-world/"/>
    <id>http://daofenglee.cn/2020/07/23/hello-world/</id>
    <published>2020-07-23T09:51:57.809Z</published>
    <updated>2020-08-01T14:40:05.701Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="实验" scheme="http://daofenglee.cn/categories/%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="hexo" scheme="http://daofenglee.cn/tags/hexo/"/>
    
  </entry>
  
</feed>
